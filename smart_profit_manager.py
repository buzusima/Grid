"""
Smart Profit Management System
smart_profit_manager.py
Advanced profit taking with portfolio analysis, trailing stops, and intelligent closing
"""

import math
import time
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Set
from dataclasses import dataclass
from enum import Enum
import MetaTrader5 as mt5
import itertools

class ProfitStrategy(Enum):
    QUICK_SAFE = "QUICK_SAFE"       # ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πÜ ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
    BALANCED = "BALANCED"           # ‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏±‡∏ö‡∏Å‡∏≥‡πÑ‡∏£
    AGGRESSIVE = "AGGRESSIVE"       # ‡∏£‡∏≠‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏π‡∏á

class CloseReason(Enum):
    PROFIT_TARGET = "PROFIT_TARGET"
    TRAILING_STOP = "TRAILING_STOP"
    PORTFOLIO_RISK = "PORTFOLIO_RISK"
    MARKET_REVERSAL = "MARKET_REVERSAL"
    TIME_BASED = "TIME_BASED"
    EMERGENCY = "EMERGENCY"

@dataclass
class SmartPosition:
    position_id: int
    symbol: str
    direction: str  # BUY/SELL
    lot_size: float
    entry_price: float
    current_price: float
    entry_time: datetime
    pnl: float
    is_hedge: bool = False
    trailing_stop_price: Optional[float] = None
    max_profit_seen: float = 0.0
    profit_target: float = 0.0
    min_profit_lock: float = 0.0

class SmartProfitManager:
    def __init__(self, gold_grid_system, config: dict):
        self.grid_system = gold_grid_system
        self.config = config
        
        # Smart profit parameters
        self.quick_profit_multiplier = 2.5      # 0.01 lot = $2.5 target
        self.balanced_profit_multiplier = 5.0   # 0.01 lot = $5.0 target  
        self.aggressive_profit_multiplier = 10.0 # 0.01 lot = $10.0 target
        
        # üöÄ Enhanced Parameters ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö $5,000+
        self.fast_profit_enabled = True
        self.auto_reposition_enabled = True
        self.quick_close_threshold = 0.6      # ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠ profit 60% ‡∏Ç‡∏≠‡∏á‡πÄ‡∏õ‡πâ‡∏≤
        self.min_gap_for_reposition = 100     # 100 points gap minimum
        self.positions_turned_today = 0
        self.daily_profit_harvested = 0.0
        
        # Trailing stop parameters
        self.trailing_stop_distance = 50       # 50 points trailing distance
        self.min_profit_for_trailing = 2.0     # Minimum $2 profit to start trailing
        
        # Portfolio protection
        self.max_portfolio_risk_pct = 15.0     # 15% max portfolio risk
        self.emergency_close_loss_pct = 25.0   # 25% emergency close
        
        # Time-based management
        self.max_position_age_minutes = 60     # 1 hour max age
        self.profit_lock_after_minutes = 30    # Lock profit after 30 min
        
        # Strategy selection based on account size
        account_info = gold_grid_system.mt5_connector.get_account_info()
        balance = account_info.get('balance', 1000) if account_info else 1000
        
        if balance >= 10000:
            self.default_strategy = ProfitStrategy.AGGRESSIVE
        elif balance >= 3000:
            self.default_strategy = ProfitStrategy.BALANCED
        else:
            self.default_strategy = ProfitStrategy.QUICK_SAFE
       
        self.recovery_enabled = config.get('portfolio_recovery', {}).get('enabled', True)
        self.recovery_trigger_loss = config.get('portfolio_recovery', {}).get('trigger_loss', -50)
        self.recovery_auto_mode = config.get('portfolio_recovery', {}).get('auto_mode', False)
        self.recovery_active = False
        self.recovery_start_time = None
        self.recovery_initial_pnl = 0
        
        print(f"üíä Portfolio Recovery System:")
        print(f"   Enabled: {self.recovery_enabled}")
        print(f"   Trigger Loss: ${abs(self.recovery_trigger_loss)}")
        print(f"   Auto Mode: {self.recovery_auto_mode}")    
        print(f"üß† Smart Profit Manager initialized:")
        print(f"   üí∞ Balance: ${balance:,.0f}")
        print(f"   üéØ Strategy: {self.default_strategy.value}")
        print(f"   üìà Trailing Stop: {self.trailing_stop_distance} points")
        
    def calculate_smart_profit_target(self, lot_size: float, strategy: ProfitStrategy = None) -> Dict:
        """Calculate intelligent profit target based on lot size and strategy"""
        
        if strategy is None:
            strategy = self.default_strategy
            
        # Base calculation: reasonable profit per lot
        if strategy == ProfitStrategy.QUICK_SAFE:
            base_target = lot_size * 100 * 1.5  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 2.5 ‡πÄ‡∏õ‡πá‡∏ô 1.5 (‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô)
            trailing_start = base_target * 0.5   # ‡πÄ‡∏£‡∏¥‡πà‡∏° trailing ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
        elif strategy == ProfitStrategy.BALANCED:
            base_target = lot_size * 100 * 3.0   # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 5.0 ‡πÄ‡∏õ‡πá‡∏ô 3.0
            trailing_start = base_target * 0.6
        else:  # AGGRESSIVE
            base_target = lot_size * 100 * 7.0   # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 10.0 ‡πÄ‡∏õ‡πá‡∏ô 7.0
            trailing_start = base_target * 0.7            
        return {
            'profit_target': round(base_target, 2),
            'trailing_start': round(trailing_start, 2),
            'partial_close_target': round(base_target * 0.5, 2),  # Close 50% early
            'min_profit_lock': round(base_target * 0.3, 2),       # Lock minimum 30%
            'strategy': strategy.value
        }
    
    def auto_reposition_after_close(self, closed_position):
        """‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡∏Å‡∏≥‡πÑ‡∏£ - ‡πÄ‡∏Å‡πá‡∏ö‡∏Å‡∏≥‡πÑ‡∏£‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á"""
        try:
            if not self.auto_reposition_enabled:
                return
                
            current_price = self.grid_system.get_current_price()
            
            # ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
            direction = closed_position.direction
            position_id = f"REPO_{direction}_{int(time.time())}"
            
            if direction == "BUY":
                # ‡∏ß‡∏≤‡∏á BUY ‡πÉ‡∏´‡∏°‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
                new_price = current_price - (self.min_gap_for_reposition * 0.01)
            else:
                # ‡∏ß‡∏≤‡∏á SELL ‡πÉ‡∏´‡∏°‡πà‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô  
                new_price = current_price + (self.min_gap_for_reposition * 0.01)
                
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ö‡πÑ‡∏°‡πâ‡πÄ‡∏î‡∏¥‡∏°
            if not self.is_too_close_to_existing(new_price, direction):
                success = self.place_replacement_position(direction, new_price, closed_position.lot_size)
                if success:
                    self.positions_turned_today += 1
                    print(f"üîÑ Auto repositioned: {direction} @ {new_price:.2f}")
                    
        except Exception as e:
            print(f"‚ùå Auto reposition error: {e}")

    def is_too_close_to_existing(self, price: float, direction: str) -> bool:
        """‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÑ‡∏°‡πâ‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡πÑ‡∏´‡∏°"""
        min_distance = self.min_gap_for_reposition * 0.01
        
        for grid_level in self.grid_system.pending_orders.values():
            if (grid_level.direction == direction and 
                abs(grid_level.price - price) < min_distance):
                return True
        return False

    def place_replacement_position(self, direction: str, price: float, lot_size: float) -> bool:
        """‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡∏ó‡∏î‡πÅ‡∏ó‡∏ô"""
        try:
            from ai_gold_grid import GridLevel, PositionStatus
            
            new_level = GridLevel(
                level_id=f"FAST_{direction}_{int(time.time())}",
                price=round(price, 5),
                lot_size=lot_size,
                direction=direction,
                status=PositionStatus.PENDING,
                entry_time=datetime.now()
            )
            
            order_result = self.grid_system.place_pending_order(new_level)
            if order_result:
                new_level.order_id = order_result
                self.grid_system.grid_levels.append(new_level)
                self.grid_system.pending_orders[order_result] = new_level
                return True
                
        except Exception as e:
            print(f"‚ùå Replacement position error: {e}")
        return False
    
    def analyze_portfolio_positions(self) -> Dict:
        """AI Portfolio Analysis - ‡∏ó‡∏±‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏•‡∏¢"""
        
        try:
            # Get all positions from MT5
            positions = mt5.positions_get(symbol=self.grid_system.gold_symbol)
            if not positions:
                return {'total_positions': 0, 'grid_positions': [], 'total_pnl': 0}
                
            # Filter our positions
            our_positions = [pos for pos in positions if pos.magic == self.grid_system.magic_number]
            
            # Create SmartPosition objects
            grid_positions = []
            hedge_positions = []
            
            for pos in our_positions:
                smart_pos = SmartPosition(
                    position_id=pos.ticket,
                    symbol=pos.symbol,
                    direction="BUY" if pos.type == mt5.POSITION_TYPE_BUY else "SELL",
                    lot_size=pos.volume,
                    entry_price=pos.price_open,
                    current_price=pos.price_current,
                    entry_time=datetime.fromtimestamp(pos.time),
                    pnl=pos.profit,
                    is_hedge="HEDGE" in pos.comment if hasattr(pos, 'comment') else False
                )
                
                if smart_pos.is_hedge:
                    hedge_positions.append(smart_pos)
                else:
                    grid_positions.append(smart_pos)
            
            # Calculate metrics
            total_pnl = sum(pos.pnl for pos in grid_positions + hedge_positions)
            
            # Portfolio scoring
            profitable_positions = [p for p in grid_positions if p.pnl > 0]
            losing_positions = [p for p in grid_positions if p.pnl < 0]
            
            print(f"üìä Portfolio: {len(grid_positions)} total, {len(profitable_positions)} profit, {len(losing_positions)} loss")
            
            return {
                'total_positions': len(grid_positions),
                'hedge_positions': len(hedge_positions), 
                'total_pnl': round(total_pnl, 2),
                'grid_positions': grid_positions,
                'hedge_positions': hedge_positions,
                'profitable_count': len(profitable_positions),
                'losing_count': len(losing_positions),
                'balance': self.get_account_balance(),
                'analysis_time': datetime.now().isoformat()
            }
            
        except Exception as e:
            print(f"‚ùå Portfolio analysis error: {e}")
            return {'error': str(e)}
    
    def get_account_balance(self) -> float:
        """‡∏î‡∏∂‡∏á account balance"""
        try:
            account_info = self.grid_system.mt5_connector.get_account_info()
            return account_info.get('balance', 1000) if account_info else 1000
        except:
            return 1000

    def get_profit_management_status(self) -> Dict:
        """AI Portfolio Status - ‡∏ó‡∏±‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏•‡∏¢"""
        
        try:
            portfolio = self.analyze_portfolio_positions()
            
            if 'error' in portfolio:
                return {'error': portfolio['error']}
            
            positions = portfolio.get('grid_positions', [])
            
            # AI Portfolio metrics
            buy_positions = [p for p in positions if p.direction == "BUY"]
            sell_positions = [p for p in positions if p.direction == "SELL"]
            
            # Find best opportunities
            profitable_pairs = self.find_profitable_pairs(positions)
            hedge_opportunities = self.find_hedge_opportunities(positions)
            
            # Portfolio health score (0-100)
            health_score = self.calculate_portfolio_health_score(portfolio)
            
            return {
                'strategy': f"AI_PORTFOLIO_{self.default_strategy.value}",
                'total_positions': portfolio.get('total_positions', 0),
                'buy_positions': len(buy_positions),
                'sell_positions': len(sell_positions),
                'hedge_positions': portfolio.get('hedge_positions', 0),
                'total_pnl': portfolio.get('total_pnl', 0),
                'profitable_pairs_found': len(profitable_pairs),
                'hedge_opportunities': len(hedge_opportunities),
                'portfolio_health': health_score,
                'trailing_stops_active': 0,  # ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ trailing stops ‡πÅ‡∏•‡πâ‡∏ß
                'risk_percentage': abs(portfolio.get('total_pnl', 0)) / portfolio.get('balance', 1000) * 100,
                'ai_mode': 'ACTIVE',
                'last_update': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {'error': str(e)}

    def calculate_portfolio_health_score(self, portfolio) -> int:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì portfolio health score (0-100)"""
        
        try:
            total_pnl = portfolio.get('total_pnl', 0)
            total_positions = portfolio.get('total_positions', 0)
            profitable_count = portfolio.get('profitable_count', 0)
            losing_count = portfolio.get('losing_count', 0)
            balance = portfolio.get('balance', 1000)
            
            # Base score
            health_score = 50
            
            # PnL factor
            pnl_ratio = total_pnl / balance * 100
            if pnl_ratio > 5:
                health_score += 30  # Very good
            elif pnl_ratio > 0:
                health_score += 15  # Good
            elif pnl_ratio > -5:
                health_score += 0   # Neutral
            elif pnl_ratio > -15:
                health_score -= 20  # Bad
            else:
                health_score -= 40  # Very bad
            
            # Position balance factor
            if total_positions > 0:
                balance_ratio = abs(profitable_count - losing_count) / total_positions
                if balance_ratio < 0.3:
                    health_score += 20  # Well balanced
                elif balance_ratio < 0.6:
                    health_score += 10  # Moderately balanced
                else:
                    health_score -= 10  # Imbalanced
            
            # Bounds
            health_score = max(0, min(health_score, 100))
            
            return int(health_score)
            
        except Exception as e:
            print(f"‚ùå Health score calculation error: {e}")
            return 50

    def identify_profit_opportunities(self, portfolio_analysis: Dict) -> List:
        """AI ‡∏´‡∏≤‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏ó‡∏≥‡∏Å‡∏≥‡πÑ‡∏£ - ‡∏ó‡∏±‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏•‡∏¢"""
        
        opportunities = []
        
        try:
            positions = portfolio_analysis.get('grid_positions', [])
            total_pnl = portfolio_analysis.get('total_pnl', 0)
            
            # 1. ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏õ‡∏¥‡∏î
            profitable_pairs = self.find_profitable_pairs(positions)
            for pair in profitable_pairs:
                opportunities.append({
                    'type': 'PAIR_CLOSE',
                    'priority': 'HIGH',
                    'expected_profit': pair['net_profit'],
                    'action': f"Close pair: {pair['losing_position'].position_id} + {pair['profit_position'].position_id}",
                    'data': pair
                })
            
            # 2. ‡∏´‡∏≤ hedge opportunities
            if total_pnl < -20:
                hedge_ops = self.find_hedge_opportunities(positions)
                for hedge in hedge_ops:
                    opportunities.append({
                        'type': 'HEDGE_PLACEMENT',
                        'priority': 'MEDIUM', 
                        'expected_profit': abs(hedge['target_loss']) * 0.3,  # ‡∏Ñ‡∏≤‡∏î‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏•‡∏î‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô 30%
                        'action': f"Place {hedge['direction']} hedge {hedge['lot_size']} lots",
                        'data': hedge
                    })
            
            # 3. Portfolio rebalancing
            buy_count = len([p for p in positions if p.direction == "BUY"])
            sell_count = len([p for p in positions if p.direction == "SELL"])
            if abs(buy_count - sell_count) > 2:
                opportunities.append({
                    'type': 'REBALANCE',
                    'priority': 'LOW',
                    'expected_profit': 5,  # Expected small profit from balance
                    'action': f"Add {'SELL' if buy_count > sell_count else 'BUY'} order for balance",
                    'data': {'imbalance': abs(buy_count - sell_count)}
                })
            
            # Sort by priority and expected profit
            priority_order = {'HIGH': 3, 'MEDIUM': 2, 'LOW': 1}
            opportunities.sort(key=lambda x: (priority_order[x['priority']], x['expected_profit']), reverse=True)
            
            return opportunities[:5]  # Top 5 opportunities
            
        except Exception as e:
            print(f"‚ùå Identify opportunities error: {e}")
            return []

    def execute_smart_close(self, position, reason, details: Dict) -> bool:
        """AI Smart Close - ‡∏ó‡∏±‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏•‡∏¢ (‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢)"""
        
        try:
            # ‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏•‡∏¢ (‡πÑ‡∏°‡πà‡∏°‡∏µ partial close ‡πÉ‡∏´‡πâ‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô)
            success = self.close_entire_position(position)
            
            if success:
                print(f"‚úÖ AI Close: {position.position_id} - ${position.pnl:.2f} - Reason: {reason.value if hasattr(reason, 'value') else reason}")
                
                # ‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏î‡πÅ‡∏ó‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
                self.place_smart_replacement_after_close(position)
                
                return True
            else:
                print(f"‚ùå AI Close failed: {position.position_id}")
                return False
                
        except Exception as e:
            print(f"‚ùå Smart close error: {e}")
            return False

    def place_smart_replacement_after_close(self, closed_position):
        """‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î"""
        
        try:
            current_price = self.grid_system.get_current_price()
            
            # AI ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏´‡∏°‡πà
            if closed_position.pnl > 0:
                # ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£ = ‡∏ß‡∏≤‡∏á‡πÉ‡∏Å‡∏•‡πâ‡πÜ ‡πÄ‡∏î‡∏¥‡∏° (‡∏Ñ‡∏≤‡∏î‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏ï‡πà‡∏≠)
                distance = 150  # 150 points
            else:
                # ‡∏õ‡∏¥‡∏î‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô = ‡∏ß‡∏≤‡∏á‡πÑ‡∏Å‡∏•‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡∏´‡∏ô‡πà‡∏≠‡∏¢ (‡πÉ‡∏´‡πâ‡πÄ‡∏ß‡∏•‡∏≤ market ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏±‡∏ß)
                distance = 250  # 250 points
                
            if closed_position.direction == "BUY":
                new_price = current_price - (distance * 0.01)
                new_direction = "BUY"
            else:
                new_price = current_price + (distance * 0.01) 
                new_direction = "SELL"
            
            # ‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà
            success = self.place_single_replacement_order(new_direction, new_price, closed_position.lot_size)
            if success:
                print(f"   üîÑ AI Replacement: {new_direction} @ ${new_price:.2f} (distance: {distance}pts)")
            
        except Exception as e:
            print(f"‚ùå Smart replacement error: {e}")
        
    def identify_profit_opportunities(self, portfolio_analysis: Dict) -> List[Tuple[SmartPosition, CloseReason, Dict]]:
        """Identify positions ready for profit taking"""
        
        opportunities = []
        
        if 'grid_positions' not in portfolio_analysis:
            return opportunities
            
        for position in portfolio_analysis['grid_positions']:
            try:
                # Calculate profit targets for this position
                targets = self.calculate_smart_profit_target(position.lot_size)
                
                # Check various profit-taking conditions
                close_decision = self.evaluate_close_decision(position, targets, portfolio_analysis)
                
                if close_decision['should_close']:
                    opportunities.append((
                        position, 
                        close_decision['reason'], 
                        close_decision['details']
                    ))
                    
            except Exception as e:
                print(f"‚ùå Profit opportunity analysis error for {position.position_id}: {e}")
                
        return opportunities
        
    def evaluate_close_decision(self, position: SmartPosition, targets: Dict, portfolio_analysis: Dict) -> Dict:
        """Evaluate whether a position should be closed"""
        
        # Position age
        position_age = (datetime.now() - position.entry_time).total_seconds() / 60  # minutes
        
        # Portfolio risk
        portfolio_risk = portfolio_analysis.get('risk_percentage', 0)
        
        # 1. Quick profit target reached
        if position.pnl >= targets['profit_target']:
            return {
                'should_close': True,
                'reason': CloseReason.PROFIT_TARGET,
                'details': {
                    'target_reached': targets['profit_target'],
                    'actual_profit': position.pnl,
                    'close_percentage': 100
                }
            }
            
        # 2. Partial profit taking
        if position.pnl >= targets['partial_close_target']:
            return {
                'should_close': True,
                'reason': CloseReason.PROFIT_TARGET,
                'details': {
                    'target_reached': targets['partial_close_target'],
                    'actual_profit': position.pnl,
                    'close_percentage': 50  # Close 50% only
                }
            }
            
        # 3. Portfolio risk too high - take any profit
        if portfolio_risk > self.max_portfolio_risk_pct and position.pnl > 1.0:
            return {
                'should_close': True,
                'reason': CloseReason.PORTFOLIO_RISK,
                'details': {
                    'portfolio_risk': portfolio_risk,
                    'max_allowed': self.max_portfolio_risk_pct,
                    'close_percentage': 100
                }
            }
            
        # 4. Time-based profit taking
        if (position_age > self.max_position_age_minutes and 
            position.pnl >= targets['min_profit_lock']):
            return {
                'should_close': True,
                'reason': CloseReason.TIME_BASED,
                'details': {
                    'position_age': position_age,
                    'max_age': self.max_position_age_minutes,
                    'profit_locked': position.pnl,
                    'close_percentage': 100
                }
            }
            
        # 5. Market reversal detection (simplified)
        if self.detect_market_reversal(position):
            return {
                'should_close': True,
                'reason': CloseReason.MARKET_REVERSAL,
                'details': {
                    'reversal_detected': True,
                    'close_percentage': 75  # Close 75% on reversal
                }
            }
            
        # 6. Emergency conditions
        if portfolio_analysis.get('total_pnl', 0) < -portfolio_analysis.get('balance', 1000) * 0.1:
            # If portfolio losing more than 10% of balance, close any profit
            if position.pnl > 0:
                return {
                    'should_close': True,
                    'reason': CloseReason.EMERGENCY,
                    'details': {
                        'emergency_triggered': True,
                        'portfolio_loss': portfolio_analysis.get('total_pnl', 0),
                        'close_percentage': 100
                    }
                }
                
        return {'should_close': False}
        
    def detect_market_reversal(self, position: SmartPosition) -> bool:
        """Simple market reversal detection"""
        
        try:
            # Get recent price history from grid system
            if not hasattr(self.grid_system, 'price_history') or len(self.grid_system.price_history) < 10:
                return False
                
            recent_prices = [p['price'] for p in self.grid_system.price_history[-10:]]
            
            # Calculate price trend
            price_change = recent_prices[-1] - recent_prices[0]
            
            # If position is BUY and price dropping fast
            if position.direction == "BUY" and price_change < -20:  # 20 point drop
                return True
                
            # If position is SELL and price rising fast  
            if position.direction == "SELL" and price_change > 20:   # 20 point rise
                return True
                
            return False
            
        except Exception as e:
            print(f"‚ùå Reversal detection error: {e}")
            return False
            
    def execute_smart_close(self, position: SmartPosition, reason: CloseReason, details: Dict) -> bool:
        """Execute intelligent position closing"""
        
        try:
            close_percentage = details.get('close_percentage', 100)
            
            if close_percentage >= 100:
                # Close entire position
                success = self.close_entire_position(position)
                if success:
                    print(f"‚úÖ FULL CLOSE: {position.position_id} - Reason: {reason.value}")
                    print(f"   üí∞ Profit: ${position.pnl:.2f} | Lot: {position.lot_size}")
                    
                    # üîÑ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ - Auto reposition ‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡πÄ‡∏ï‡πá‡∏°
                    self.auto_reposition_after_close(position)
                    self.daily_profit_harvested += position.pnl
                    
                return success
                
            else:
                # Partial close
                close_volume = position.lot_size * (close_percentage / 100)
                success = self.partial_close_position(position, close_volume)
                if success:
                    print(f"‚úÖ PARTIAL CLOSE: {position.position_id} - {close_percentage}% - Reason: {reason.value}")
                    print(f"   üí∞ Estimated Profit: ${position.pnl * (close_percentage/100):.2f}")
                    
                    # üîÑ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ - Track partial profit
                    partial_profit = position.pnl * (close_percentage / 100)
                    self.daily_profit_harvested += partial_profit
                    
                    # ‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 50% ‡πÉ‡∏´‡πâ reposition ‡πÉ‡∏´‡∏°‡πà
                    if close_percentage >= 50:
                        self.auto_reposition_after_close(position)
                    
                return success
                
        except Exception as e:
            print(f"‚ùå Smart close execution error: {e}")
            return False
                
    def close_entire_position(self, position: SmartPosition) -> bool:
        """Close entire position"""
        
        try:
            # Get current tick
            tick = mt5.symbol_info_tick(self.grid_system.gold_symbol)
            if not tick:
                return False
                
            # Determine close parameters
            if position.direction == "BUY":
                trade_type = mt5.ORDER_TYPE_SELL
                price = tick.bid
            else:
                trade_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
                
            # Close request
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": self.grid_system.gold_symbol,
                "volume": position.lot_size,
                "type": trade_type,
                "position": position.position_id,
                "price": price,
                "deviation": 20,
                "magic": self.grid_system.magic_number,
                "comment": "SmartProfit_FullClose",
                "type_filling": self.grid_system.close_filling_mode
            }
            
            result = mt5.order_send(request)
            return result and result.retcode == mt5.TRADE_RETCODE_DONE
            
        except Exception as e:
            print(f"‚ùå Full close error: {e}")
            return False
                        
    def run_smart_profit_management(self):
        """üß† AI MASTER CONTROLLER - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method name errors"""
        try:
            print("üß† AI MASTER CONTROLLER - ANALYZING PORTFOLIO")
            
            # 1. ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå positions ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            portfolio = self.analyze_portfolio_positions()
            if 'error' in portfolio or portfolio.get('total_positions', 0) == 0:
                print("üîÑ No positions detected - AI creating intelligent grid")
                self.create_grid_immediately()  # ‚úÖ ‡πÉ‡∏ä‡πâ AI version
                return
                
            positions = portfolio.get('grid_positions', [])
            total_pnl = portfolio.get('total_pnl', 0)
            
            print(f"üìä Portfolio Status: {len(positions)} positions, PnL: ${total_pnl:.2f}")
            
            # üß† AI ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö survivability ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            if hasattr(self, 'ai_grid_config'):
                target_survivability = self.ai_grid_config.get('target_survivability', 10000)
                current_coverage = self.estimate_current_survivability(positions)
                survivability_ratio = current_coverage / target_survivability
                
                print(f"üõ°Ô∏è AI SURVIVABILITY CHECK: {current_coverage:,}/{target_survivability:,} points ({survivability_ratio:.1%})")
                
                if survivability_ratio < 0.6:  # ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 60% ‡∏Ç‡∏≠‡∏á target
                    print("üö® AI: SURVIVABILITY CRITICAL - Adding protective positions")
                    # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
                    self.rebalance_portfolio_if_needed(positions)
                    return
            
            # 2. üß† AI ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏â‡∏•‡∏≤‡∏î (‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏â‡∏•‡∏≤‡∏î‡πÅ‡∏•‡πâ‡∏ß)
            profitable_pairs = self.find_profitable_pairs(positions)
            
            if profitable_pairs:
                print(f"üí∞ AI PROFIT OPPORTUNITY: {len(profitable_pairs)} intelligent closes")
                self.execute_pair_closes(profitable_pairs)
                time.sleep(1)
                
                # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó portfolio ‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î
                portfolio = self.analyze_portfolio_positions()
                positions = portfolio.get('grid_positions', [])
                
                # üß† AI ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß survivability ‡∏¢‡∏±‡∏á‡∏û‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                if len(positions) < 4:
                    print("üîß AI: Post-close analysis - Need more coverage")
                    # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
                    self.rebalance_portfolio_if_needed(positions)
            
            # 3. üß† AI Portfolio Health Check
            buy_count = len([p for p in positions if p.direction == "BUY"])
            sell_count = len([p for p in positions if p.direction == "SELL"])
            
            if buy_count == 0 or sell_count == 0:
                print(f"üö® AI: CRITICAL IMBALANCE {buy_count}:{sell_count}")
                current_price = self.grid_system.get_current_price()
                self.smart_rebalance_immediately(current_price, buy_count, sell_count)
            elif abs(buy_count - sell_count) >= 3:
                print(f"‚öñÔ∏è AI: REBALANCING NEEDED {buy_count}:{sell_count}")
                # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
                self.rebalance_portfolio_if_needed(positions)
            else:
                print(f"‚úÖ AI: Portfolio healthy {buy_count}:{sell_count}")
            
        except Exception as e:
            print(f"‚ùå AI Master Controller error: {e}")

    def rebalance_portfolio_if_needed(self, positions):
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method ‡πÄ‡∏î‡∏¥‡∏° - ‡πÄ‡∏û‡∏¥‡πà‡∏° AI Intelligence"""
        try:
            current_price = self.grid_system.get_current_price()
            buy_count = len([p for p in positions if p.direction == "BUY"])
            sell_count = len([p for p in positions if p.direction == "SELL"])
            
            # üß† ‡πÉ‡∏ä‡πâ AI config ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if hasattr(self, 'ai_grid_config'):
                spacing = self.ai_grid_config.get('optimal_spacing', 500)
                base_lot = self.ai_grid_config.get('base_lot', 0.01)
                target_survivability = self.ai_grid_config.get('target_survivability', 10000)
                print(f"üß† AI REBALANCING: Using AI config - spacing {spacing}, lot {base_lot:.3f}")
            else:
                # Fallback ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ AI config
                account_info = self.grid_system.mt5_connector.get_account_info()
                balance = account_info.get('balance', 5000) if account_info else 5000
                spacing = 500 if balance < 10000 else 400
                base_lot = self.grid_system.base_lot
                target_survivability = 10000
                print(f"üîß FALLBACK REBALANCING: spacing {spacing}, lot {base_lot:.3f}")
            
            print(f"üìä Portfolio: {buy_count} BUY, {sell_count} SELL @ ${current_price:.2f}")
            
            # üß† AI ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö coverage ‡∏Å‡πà‡∏≠‡∏ô
            total_positions = buy_count + sell_count
            if total_positions > 0:
                estimated_coverage = total_positions * spacing
                coverage_ratio = estimated_coverage / target_survivability
                
                print(f"üõ°Ô∏è Coverage Analysis: {estimated_coverage:,} points ({coverage_ratio:.1%} of target)")
                
                # ‡∏ñ‡πâ‡∏≤ coverage ‡∏ï‡πà‡∏≥‡∏°‡∏≤‡∏Å ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏° orders
                if coverage_ratio < 0.6:  # ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 60% ‡∏Ç‡∏≠‡∏á target
                    print("üîß AI: Coverage too low, adding protective orders")
                    needed_orders = min(3, int((target_survivability - estimated_coverage) / spacing / 2))
                    
                    for i in range(1, needed_orders + 1):
                        buy_price = current_price - (spacing * (buy_count + i) * 0.01)
                        sell_price = current_price + (spacing * (sell_count + i) * 0.01)
                        
                        if self.grid_system.place_smart_rebalance_order("BUY", buy_price, base_lot):
                            print(f"   ‚úÖ Protective BUY: @ ${buy_price:.2f}")
                        if self.grid_system.place_smart_rebalance_order("SELL", sell_price, base_lot):
                            print(f"   ‚úÖ Protective SELL: @ ${sell_price:.2f}")
                        time.sleep(0.5)
                    
                    return
            
            # üéØ Normal imbalance rebalancing
            imbalance = abs(buy_count - sell_count)
            if imbalance >= 2:  # ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ imbalance ‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                if buy_count > sell_count:  # BUY ‡πÄ‡∏¢‡∏≠‡∏∞
                    needed = min(imbalance, 2)  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 2
                    print(f"‚öñÔ∏è Adding {needed} SELL orders to balance")
                    for i in range(needed):
                        sell_price = current_price + (spacing * (i + 1) * 0.01)
                        if self.grid_system.place_smart_rebalance_order("SELL", sell_price, base_lot):
                            print(f"   ‚úÖ Balance SELL: @ ${sell_price:.2f}")
                            time.sleep(0.5)
                
                elif sell_count > buy_count:  # SELL ‡πÄ‡∏¢‡∏≠‡∏∞
                    needed = min(imbalance, 2)  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 2
                    print(f"‚öñÔ∏è Adding {needed} BUY orders to balance")
                    for i in range(needed):
                        buy_price = current_price - (spacing * (i + 1) * 0.01)
                        if self.grid_system.place_smart_rebalance_order("BUY", buy_price, base_lot):
                            print(f"   ‚úÖ Balance BUY: @ ${buy_price:.2f}")
                            time.sleep(0.5)
                
                print(f"‚úÖ Portfolio rebalanced with {target_survivability:,} point protection")
            else:
                print("‚úÖ Portfolio balance within acceptable range")
                
        except Exception as e:
            print(f"‚ùå Rebalance error: {e}")

    def create_grid_immediately(self):
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method ‡πÄ‡∏î‡∏¥‡∏° - ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏≤‡∏Å create_safe_initial_grid"""
        try:
            current_price = self.grid_system.get_current_price()
            if not current_price:
                print("‚ùå Cannot get current price")
                return
            
            # üß† ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Account ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì AI parameters
            account_info = self.grid_system.mt5_connector.get_account_info()
            balance = account_info.get('balance', 5000) if account_info else 5000
            margin_level = account_info.get('margin_level', 300) if account_info else 300
            
            print(f"üß† AI GRID CREATION @ ${current_price:.2f}")
            print(f"   üí∞ Balance: ${balance:,.0f}, Margin: {margin_level:.1f}%")
            
            # üéØ AI ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì parameters ‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô
            if balance >= 50000:
                target_survivability = 20000
                base_lot = round(balance * 0.6 / 150000, 3)
                spacing = 600
            elif balance >= 20000:
                target_survivability = 15000
                base_lot = round(balance * 0.6 / 120000, 3)
                spacing = 500
            elif balance >= 5000:
                target_survivability = 10000
                base_lot = round(balance * 0.6 / 100000, 3)
                spacing = 400
            else:
                target_survivability = 8000
                base_lot = round(balance * 0.6 / 80000, 3)
                spacing = 350
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô minimum lot
            base_lot = max(base_lot, 0.01)
            
            print(f"üéØ AI TARGET: {target_survivability:,} points survivability")
            print(f"üíé Calculated: Lot {base_lot:.3f}, Spacing {spacing} points")
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á grid ‡πÅ‡∏ö‡∏ö layered
            orders_to_create = [
                # Near layer
                ("BUY", current_price - (spacing * 0.5 * 0.01), base_lot),
                ("SELL", current_price + (spacing * 0.5 * 0.01), base_lot),
                # Medium layer  
                ("BUY", current_price - (spacing * 1.0 * 0.01), base_lot),
                ("SELL", current_price + (spacing * 1.0 * 0.01), base_lot),
                # Far layer
                ("BUY", current_price - (spacing * 2.0 * 0.01), base_lot),
                ("SELL", current_price + (spacing * 2.0 * 0.01), base_lot)
            ]
            
            orders_placed = 0
            for direction, price, lot_size in orders_to_create:
                if self.grid_system.place_smart_rebalance_order(direction, price, lot_size):
                    orders_placed += 1
                    distance = abs(price - current_price) / 0.01
                    print(f"   ‚úÖ {direction}: {lot_size:.3f} @ ${price:.2f} ({distance:.0f} pts)")
                    time.sleep(0.3)
                else:
                    print(f"   ‚ùå Failed {direction} @ ${price:.2f}")
            
            # üß† ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å AI config
            self.ai_grid_config = {
                'target_survivability': target_survivability,
                'optimal_spacing': spacing,
                'base_lot': base_lot,
                'last_calculated': datetime.now()
            }
            
            print(f"‚úÖ AI GRID COMPLETE: {orders_placed}/6 orders")
            print(f"üõ°Ô∏è Target survivability: {target_survivability:,} points")
            
        except Exception as e:
            print(f"‚ùå Grid creation error: {e}")

    def estimate_current_survivability(self, positions) -> int:
        """üß† ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô survivability ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        try:
            if not positions:
                return 0
            
            current_price = self.grid_system.get_current_price()
            
            # ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÑ‡∏Å‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
            buy_positions = [p for p in positions if p.direction == "BUY"]
            sell_positions = [p for p in positions if p.direction == "SELL"]
            
            max_buy_distance = 0
            max_sell_distance = 0
            
            if buy_positions:
                farthest_buy = min(buy_positions, key=lambda x: x.entry_price)
                max_buy_distance = abs(current_price - farthest_buy.entry_price) / 0.01
            
            if sell_positions:
                farthest_sell = max(sell_positions, key=lambda x: x.entry_price)
                max_sell_distance = abs(farthest_sell.entry_price - current_price) / 0.01
            
            # ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô survivability ‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏¢‡∏∞‡πÑ‡∏Å‡∏•‡∏™‡∏∏‡∏î
            estimated_survivability = int(max(max_buy_distance, max_sell_distance) * 1.5)  # ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡πÑ‡∏ß‡πâ
            
            return estimated_survivability
            
        except Exception as e:
            print(f"‚ùå Estimate survivability error: {e}")
            return 0
        
    def smart_rebalance_immediately(self, current_price, buy_count, sell_count):
        """üß† AI INTELLIGENT REBALANCE - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å method ‡πÄ‡∏î‡∏¥‡∏°"""
        try:
            # üß† ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà AI ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß
            if hasattr(self, 'ai_grid_config'):
                spacing = self.ai_grid_config.get('optimal_spacing', 500)
                base_lot = self.ai_grid_config.get('base_lot', 0.01)
                risk_tolerance = self.ai_grid_config.get('risk_tolerance', 'MODERATE')
            else:
                # Fallback calculation
                account_info = self.grid_system.mt5_connector.get_account_info()
                balance = account_info.get('balance', 5000) if account_info else 5000
                spacing = 500 if balance < 10000 else 400
                base_lot = 0.01
                risk_tolerance = 'MODERATE'
            
            print(f"üß† AI REBALANCE: Using spacing {spacing} points, lot {base_lot:.3f}")
            
            orders_added = 0
            max_orders = 3 if risk_tolerance == 'AGGRESSIVE' else 2
            
            if buy_count == 0 and sell_count > 0:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ BUY ‡πÄ‡∏•‡∏¢
                print("üöÄ AI: Adding strategic BUY orders")
                for i in range(1, max_orders + 1):
                    buy_price = current_price - (spacing * i * 0.01)
                    if self.grid_system.place_smart_rebalance_order("BUY", buy_price, base_lot):
                        orders_added += 1
                        print(f"   ‚úÖ Strategic BUY: @ ${buy_price:.2f} ({spacing * i} pts)")
                        time.sleep(0.3)
            
            elif sell_count == 0 and buy_count > 0:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ SELL ‡πÄ‡∏•‡∏¢
                print("üöÄ AI: Adding strategic SELL orders")
                for i in range(1, max_orders + 1):
                    sell_price = current_price + (spacing * i * 0.01)
                    if self.grid_system.place_smart_rebalance_order("SELL", sell_price, base_lot):
                        orders_added += 1
                        print(f"   ‚úÖ Strategic SELL: @ ${sell_price:.2f} ({spacing * i} pts)")
                        time.sleep(0.3)
            
            print(f"üß† AI REBALANCE COMPLETE: {orders_added} strategic orders added")
            
        except Exception as e:
            print(f"‚ùå AI rebalance error: {e}")

    def smart_rebalance_immediately(self, current_price, buy_count, sell_count):
            """üß† AI INTELLIGENT REBALANCE - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å method ‡πÄ‡∏î‡∏¥‡∏°"""
            try:
                # üß† ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà AI ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß
                if hasattr(self, 'ai_grid_config'):
                    spacing = self.ai_grid_config.get('optimal_spacing', 500)
                    base_lot = self.ai_grid_config.get('base_lot', 0.01)
                    risk_tolerance = self.ai_grid_config.get('risk_tolerance', 'MODERATE')
                else:
                    # Fallback calculation
                    account_info = self.grid_system.mt5_connector.get_account_info()
                    balance = account_info.get('balance', 5000) if account_info else 5000
                    spacing = 500 if balance < 10000 else 400
                    base_lot = 0.01
                    risk_tolerance = 'MODERATE'
                
                print(f"üß† AI REBALANCE: Using spacing {spacing} points, lot {base_lot:.3f}")
                
                orders_added = 0
                max_orders = 3 if risk_tolerance == 'AGGRESSIVE' else 2
                
                if buy_count == 0 and sell_count > 0:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ BUY ‡πÄ‡∏•‡∏¢
                    print("üöÄ AI: Adding strategic BUY orders")
                    for i in range(1, max_orders + 1):
                        buy_price = current_price - (spacing * i * 0.01)
                        if self.grid_system.place_smart_rebalance_order("BUY", buy_price, base_lot):
                            orders_added += 1
                            print(f"   ‚úÖ Strategic BUY: @ ${buy_price:.2f} ({spacing * i} pts)")
                            time.sleep(0.3)
                
                elif sell_count == 0 and buy_count > 0:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ SELL ‡πÄ‡∏•‡∏¢
                    print("üöÄ AI: Adding strategic SELL orders")
                    for i in range(1, max_orders + 1):
                        sell_price = current_price + (spacing * i * 0.01)
                        if self.grid_system.place_smart_rebalance_order("SELL", sell_price, base_lot):
                            orders_added += 1
                            print(f"   ‚úÖ Strategic SELL: @ ${sell_price:.2f} ({spacing * i} pts)")
                            time.sleep(0.3)
                
                print(f"üß† AI REBALANCE COMPLETE: {orders_added} strategic orders added")
                
            except Exception as e:
                print(f"‚ùå AI rebalance error: {e}")

    def is_safe_to_manage(self) -> bool:
            """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method ‡πÄ‡∏î‡∏¥‡∏° - ‡πÄ‡∏≠‡∏≤ Safety ‡πÇ‡∏á‡πà‡πÜ ‡∏≠‡∏≠‡∏Å"""
            try:
                # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç market hours ‡πÇ‡∏á‡πà‡πÜ (‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ 24 ‡∏ä‡∏°.)
                # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏î margin requirement ‡∏à‡∏≤‡∏Å 200% ‡πÄ‡∏õ‡πá‡∏ô 100%
                account_info = self.grid_system.mt5_connector.get_account_info()
                if account_info:
                    margin_level = account_info.get('margin_level', 0)
                    if margin_level < 100:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 200% ‡πÄ‡∏õ‡πá‡∏ô 100%
                        print(f"üõ°Ô∏è Margin level too low: {margin_level:.1f}%")
                        return False
                    else:
                        print(f"‚úÖ Margin OK: {margin_level:.1f}%")
                
                # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏° daily loss limit ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÇ‡∏á‡πà‡∏à‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                daily_pnl = getattr(self.grid_system, 'daily_pnl', 0)
                if daily_pnl < -(self.grid_system.daily_loss_limit * 2):  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 2 ‡πÄ‡∏ó‡πà‡∏≤
                    print(f"üõ°Ô∏è Daily loss limit reached: ${daily_pnl:.2f}")
                    return False
                
                print("‚úÖ All safety checks passed")
                return True
                
            except Exception as e:
                print(f"‚ùå Safety check error: {e}")
                return True  # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ñ‡πâ‡∏≤ error ‡πÉ‡∏´‡πâ‡∏ú‡πà‡∏≤‡∏ô‡πÅ‡∏ó‡∏ô (‡πÑ‡∏°‡πà‡πÇ‡∏á‡πà)

    def should_rebuild_grid(self) -> bool:
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method ‡πÄ‡∏î‡∏¥‡∏° - ‡∏•‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÇ‡∏á‡πà‡πÜ ‡∏≠‡∏≠‡∏Å"""
        # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á grid ‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏°‡∏≠ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠
        return True

    def is_safe_to_add_positions(self) -> bool:
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method ‡πÄ‡∏î‡∏¥‡∏° - ‡∏ú‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç"""
        try:
            account_info = self.grid_system.mt5_connector.get_account_info()
            if account_info:
                free_margin = account_info.get('free_margin', 0)
                margin_level = account_info.get('margin_level', 0)
                
                # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏î‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å $1000 ‡πÄ‡∏õ‡πá‡∏ô $300, ‡πÅ‡∏•‡∏∞ 300% ‡πÄ‡∏õ‡πá‡∏ô 150%
                if free_margin < 300 or margin_level < 150:
                    print(f"‚ö†Ô∏è Limited margin: ${free_margin:.2f}, Level: {margin_level:.1f}%")
                    return False
            
            # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏° max positions ‡∏à‡∏≤‡∏Å 15 ‡πÄ‡∏õ‡πá‡∏ô 25
            current_positions = len(self.grid_system.active_positions)
            if current_positions >= 25:
                print(f"‚ö†Ô∏è Too many positions: {current_positions}/25")
                return False
                
            return True
            
        except Exception as e:
            print(f"‚ùå Safe to add check error: {e}")
            return True  # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ñ‡πâ‡∏≤ error ‡πÉ‡∏´‡πâ‡∏ú‡πà‡∏≤‡∏ô

    def is_safe_to_rebalance(self) -> bool:
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method ‡πÄ‡∏î‡∏¥‡∏° - ‡πÉ‡∏´‡πâ rebalance ‡πÑ‡∏î‡πâ‡∏ö‡πà‡∏≠‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô"""
        # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡∏à‡∏≤‡∏Å 3 ‡∏ô‡∏≤‡∏ó‡∏µ ‡πÄ‡∏õ‡πá‡∏ô 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        if not hasattr(self, 'last_rebalance_time'):
            self.last_rebalance_time = datetime.now() - timedelta(minutes=10)
        
        time_since_rebalance = (datetime.now() - self.last_rebalance_time).total_seconds()
        if time_since_rebalance < 30:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 180 ‡πÄ‡∏õ‡πá‡∏ô 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            return False
        
        return True
    def create_safe_initial_grid(self):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á grid ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å method ‡πÄ‡∏î‡∏¥‡∏°"""
        try:
            current_price = self.grid_system.get_current_price()
            if not current_price:
                return
            
            print(f"üèóÔ∏è Creating SAFE initial grid @ ${current_price:.2f}")
            
            base_lot = self.grid_system.base_lot
            spacing = 250  # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 150 ‡πÄ‡∏õ‡πá‡∏ô 250 points (‡∏´‡πà‡∏≤‡∏á‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°)
            
            # ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏Ñ‡πà 4 orders ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô (‡πÅ‡∏ó‡∏ô 6)
            orders_to_create = [
                ("BUY", current_price - (spacing * 0.01), base_lot),
                ("BUY", current_price - (spacing * 2 * 0.01), base_lot), 
                ("SELL", current_price + (spacing * 0.01), base_lot),
                ("SELL", current_price + (spacing * 2 * 0.01), base_lot)
            ]
            
            orders_placed = 0
            for direction, price, lot_size in orders_to_create:
                if self.grid_system.place_smart_rebalance_order(direction, price, lot_size):
                    orders_placed += 1
                    print(f"   ‚úÖ Safe {direction}: {lot_size:.3f} @ ${price:.2f}")
                    time.sleep(1)  # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡∏à‡∏≤‡∏Å 0.5 ‡πÄ‡∏õ‡πá‡∏ô 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                else:
                    print(f"   ‚ùå Failed {direction} @ ${price:.2f}")
            
            # ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á grid
            self.last_grid_rebuild = datetime.now()
            self.daily_rebuild_count = getattr(self, 'daily_rebuild_count', 0) + 1
            
            print(f"‚úÖ Safe grid created: {orders_placed}/4 orders (Conservative spacing: {spacing} pts)")
            
        except Exception as e:
            print(f"‚ùå Safe grid creation error: {e}")

    def safe_emergency_rebalance(self, current_price, buy_count, sell_count):
        """Emergency rebalancing ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å method ‡πÄ‡∏î‡∏¥‡∏°"""
        try:
            base_lot = self.grid_system.base_lot
            safe_spacing = 300  # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 120 ‡πÄ‡∏õ‡πá‡∏ô 300 points (‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Å‡∏ß‡πà‡∏≤)
            
            orders_added = 0
            max_orders = 2  # ‚úÖ ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 2 orders ‡∏ï‡πà‡∏≠‡∏Ñ‡∏£‡∏±‡πâ‡∏á
            
            if buy_count == 0 and sell_count >= 3:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ BUY ‡πÄ‡∏•‡∏¢
                print("üöÄ SAFE: Adding BUY orders with conservative spacing")
                for i in range(1, max_orders + 1):
                    buy_price = current_price - (safe_spacing * i * 0.01)
                    if self.grid_system.place_smart_rebalance_order("BUY", buy_price, base_lot):
                        orders_added += 1
                        print(f"   ‚úÖ Safe BUY {i}: @ ${buy_price:.2f} ({safe_spacing * i} pts)")
                        time.sleep(2)  # ‚úÖ ‡∏£‡∏≠ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á orders
            
            elif sell_count == 0 and buy_count >= 3:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ SELL ‡πÄ‡∏•‡∏¢
                print("üöÄ SAFE: Adding SELL orders with conservative spacing")
                for i in range(1, max_orders + 1):
                    sell_price = current_price + (safe_spacing * i * 0.01)
                    if self.grid_system.place_smart_rebalance_order("SELL", sell_price, base_lot):
                        orders_added += 1
                        print(f"   ‚úÖ Safe SELL {i}: @ ${sell_price:.2f} ({safe_spacing * i} pts)")
                        time.sleep(2)  # ‚úÖ ‡∏£‡∏≠ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á orders
            
            # ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ß‡∏•‡∏≤ rebalance
            self.last_rebalance_time = datetime.now()
            self.daily_rebalance_count = getattr(self, 'daily_rebalance_count', 0) + 1
            
            print(f"‚úÖ Safe emergency rebalance: {orders_added} orders added")
            
        except Exception as e:
            print(f"‚ùå Safe emergency rebalance error: {e}")

    def add_conservative_sell_orders(self, current_price, count):
        """‡πÄ‡∏û‡∏¥‡πà‡∏° SELL orders ‡πÅ‡∏ö‡∏ö‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å method ‡πÄ‡∏î‡∏¥‡∏°"""
        try:
            conservative_spacing = 350  # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 150 ‡πÄ‡∏õ‡πá‡∏ô 350 points
            
            for i in range(count):
                price = current_price + (conservative_spacing * (i + 1) * 0.01)
                
                if not self.grid_system.has_nearby_order(price, "SELL", 1.0):  # ‡πÄ‡∏û‡∏¥‡πà‡∏° tolerance
                    if self.grid_system.place_smart_rebalance_order("SELL", price, self.grid_system.base_lot):
                        print(f"   ‚úÖ Conservative SELL: @ ${price:.2f} ({conservative_spacing * (i+1)} pts)")
                        time.sleep(3)  # ‚úÖ ‡∏£‡∏≠ 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡πÄ‡∏î‡∏¥‡∏° 0.5)
                        
        except Exception as e:
            print(f"‚ùå Conservative SELL error: {e}")

    def add_conservative_buy_orders(self, current_price, count):
        """‡πÄ‡∏û‡∏¥‡πà‡∏° BUY orders ‡πÅ‡∏ö‡∏ö‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å method ‡πÄ‡∏î‡∏¥‡∏°"""
        try:
            conservative_spacing = 350  # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 150 ‡πÄ‡∏õ‡πá‡∏ô 350 points
            
            for i in range(count):
                price = current_price - (conservative_spacing * (i + 1) * 0.01)
                
                if not self.grid_system.has_nearby_order(price, "BUY", 1.0):  # ‡πÄ‡∏û‡∏¥‡πà‡∏° tolerance
                    if self.grid_system.place_smart_rebalance_order("BUY", price, self.grid_system.base_lot):
                        print(f"   ‚úÖ Conservative BUY: @ ${price:.2f} ({conservative_spacing * (i+1)} pts)")
                        time.sleep(3)  # ‚úÖ ‡∏£‡∏≠ 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡πÄ‡∏î‡∏¥‡∏° 0.5)
                        
        except Exception as e:
            print(f"‚ùå Conservative BUY error: {e}")

    def rebuild_grid_after_cleanup(self):
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç create_initial_grid_smart - ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà"""
        try:
            current_price = self.grid_system.get_current_price()
            if not current_price:
                print("‚ùå Cannot get current price for rebuilding")
                return
            
            print(f"üèóÔ∏è Rebuilding grid @ ${current_price:.2f}")
            
            base_lot = self.grid_system.base_lot
            spacing = 150  # 150 points
            orders_placed = 0
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á 3 ‡∏Ñ‡∏π‡πà orders
            for i in range(1, 4):
                buy_price = current_price - (spacing * i * 0.01)
                sell_price = current_price + (spacing * i * 0.01)
                
                # BUY order
                if self.grid_system.place_smart_rebalance_order("BUY", buy_price, base_lot):
                    orders_placed += 1
                    time.sleep(0.5)
                
                # SELL order
                if self.grid_system.place_smart_rebalance_order("SELL", sell_price, base_lot):
                    orders_placed += 1
                    time.sleep(0.5)
            
            print(f"‚úÖ Grid rebuilt: {orders_placed}/6 orders placed")
            
        except Exception as e:
            print(f"‚ùå Rebuild grid error: {e}")

    def force_rebalance_immediately(self, current_price, buy_count, sell_count):
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method - Force rebalancing ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ"""
        try:
            base_lot = self.grid_system.base_lot
            spacing = 120  # 120 points spacing (‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤)
            
            if buy_count == 0:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ BUY ‡πÄ‡∏•‡∏¢
                print("üöÄ Force adding BUY orders")
                for i in range(1, min(sell_count + 1, 4)):  # ‡πÄ‡∏û‡∏¥‡πà‡∏° BUY ‡πÉ‡∏´‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•
                    buy_price = current_price - (spacing * i * 0.01)
                    self.grid_system.place_smart_rebalance_order("BUY", buy_price, base_lot)
                    time.sleep(0.3)
            
            if sell_count == 0:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ SELL ‡πÄ‡∏•‡∏¢
                print("üöÄ Force adding SELL orders")
                for i in range(1, min(buy_count + 1, 4)):  # ‡πÄ‡∏û‡∏¥‡πà‡∏° SELL ‡πÉ‡∏´‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•
                    sell_price = current_price + (spacing * i * 0.01)
                    self.grid_system.place_smart_rebalance_order("SELL", sell_price, base_lot)
                    time.sleep(0.3)
                    
        except Exception as e:
            print(f"‚ùå Force rebalance error: {e}")

    def add_coverage_orders(self, current_price, needed_count):
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method - ‡πÄ‡∏û‡∏¥‡πà‡∏° orders ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ coverage ‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠"""
        try:
            base_lot = self.grid_system.base_lot
            spacing = 130  # 130 points
            orders_added = 0
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏•‡∏±‡∏ö BUY/SELL
            for i in range(1, (needed_count // 2) + 2):
                if orders_added >= needed_count:
                    break
                    
                # BUY order
                buy_price = current_price - (spacing * i * 0.01)
                if not self.grid_system.has_nearby_order(buy_price, "BUY", 0.5):
                    if self.grid_system.place_smart_rebalance_order("BUY", buy_price, base_lot):
                        orders_added += 1
                        time.sleep(0.3)
                
                if orders_added >= needed_count:
                    break
                
                # SELL order
                sell_price = current_price + (spacing * i * 0.01)
                if not self.grid_system.has_nearby_order(sell_price, "SELL", 0.5):
                    if self.grid_system.place_smart_rebalance_order("SELL", sell_price, base_lot):
                        orders_added += 1
                        time.sleep(0.3)
            
            print(f"üîß Coverage orders added: {orders_added}/{needed_count}")
            
        except Exception as e:
            print(f"‚ùå Add coverage orders error: {e}")

    def execute_critical_cleanup(self, positions):
        """üö® ‡πÇ‡∏´‡∏°‡∏î‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç Portfolio ‡∏ß‡∏¥‡∏Å‡∏§‡∏ï‡∏¥"""
        try:
            print("üö® Executing critical cleanup...")
            
            # ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ú‡∏¥‡∏î‡∏Ç‡πâ‡∏≤‡∏á‡∏ï‡∏•‡∏≤‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
            current_price = self.grid_system.get_current_price()
            wrong_side_pairs = self.find_wrong_side_pairs(
                [p for p in positions if p.direction == "BUY"],
                [p for p in positions if p.direction == "SELL"],
                current_price
            )
            
            if wrong_side_pairs:
                for pair in wrong_side_pairs[:2]:  # ‡∏õ‡∏¥‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 2 ‡∏Ñ‡∏π‡πà
                    self.execute_pair_close(pair)
                    time.sleep(1)
            
            # ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡∏•‡∏î margin load
            margin_pairs = self.find_margin_efficient_pairs(
                [p for p in positions if p.direction == "BUY"],
                [p for p in positions if p.direction == "SELL"]
            )
            
            if margin_pairs:
                for pair in margin_pairs[:1]:  # ‡∏õ‡∏¥‡∏î‡πÅ‡∏Ñ‡πà 1 ‡∏Ñ‡∏π‡πà
                    if pair['net_profit'] > -5:  # ‡∏¢‡∏≠‡∏°‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô $5
                        self.execute_pair_close(pair)
                        time.sleep(1)
                        
        except Exception as e:
            print(f"‚ùå Critical cleanup error: {e}")
    
    def execute_balanced_management(self, positions):
        """‚ö° ‡πÇ‡∏´‡∏°‡∏î‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•"""
        try:
            print("‚ö° Executing balanced management...")
            
            # ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≥‡πÑ‡∏£‡∏î‡∏µ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏∞‡∏ó‡∏ö portfolio
            safe_profitable_pairs = []
            
            for pair_type_func in [self.find_balanced_pairs, self.find_margin_efficient_pairs]:
                pairs = pair_type_func(
                    [p for p in positions if p.direction == "BUY"],
                    [p for p in positions if p.direction == "SELL"]
                )
                
                # ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
                for pair in pairs:
                    if pair['net_profit'] > 3 and self.is_safe_to_close(pair, positions):
                        safe_profitable_pairs.append(pair)
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° profit ‡πÅ‡∏•‡∏∞‡∏õ‡∏¥‡∏î
            safe_profitable_pairs.sort(key=lambda x: x['net_profit'], reverse=True)
            
            for pair in safe_profitable_pairs[:2]:  # ‡∏õ‡∏¥‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 2 ‡∏Ñ‡∏π‡πà
                self.execute_pair_close(pair)
                time.sleep(2)  # ‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏ô‡∏≤‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
                
        except Exception as e:
            print(f"‚ùå Balanced management error: {e}")
    
    def execute_profit_optimization(self, positions):
        """‚úÖ ‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏Å‡∏≥‡πÑ‡∏£"""
        try:
            print("‚úÖ Executing profit optimization...")
            
            # ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏Å‡∏≥‡πÑ‡∏£‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            high_profit_pairs = []
            
            all_pairs = self.find_profitable_pairs(positions)
            
            for pair in all_pairs:
                # ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏π‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏∞‡∏ó‡∏ö portfolio
                if pair['net_profit'] > 5 and self.is_optimal_close_timing(pair):
                    high_profit_pairs.append(pair)
            
            # ‡∏õ‡∏¥‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏°‡∏Ñ‡πà‡∏≤‡∏à‡∏£‡∏¥‡∏á‡πÜ
            for pair in high_profit_pairs[:3]:  # ‡∏õ‡∏¥‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 3 ‡∏Ñ‡∏π‡πà
                if self.confirm_optimal_close(pair):
                    self.execute_pair_close(pair)
                    time.sleep(1.5)
                    
        except Exception as e:
            print(f"‚ùå Profit optimization error: {e}")
    
    def is_safe_to_close(self, pair, all_positions) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∞‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÑ‡∏´‡∏°"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß portfolio ‡∏à‡∏∞‡∏¢‡∏±‡∏á‡∏™‡∏°‡∏î‡∏∏‡∏•‡πÑ‡∏´‡∏°
            remaining_positions = [p for p in all_positions 
                                 if p.position_id not in pair['position_ids']]
            
            if len(remaining_positions) < 4:  # ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                return False
            
            buy_remaining = len([p for p in remaining_positions if p.direction == "BUY"])
            sell_remaining = len([p for p in remaining_positions if p.direction == "SELL"])
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô
            if buy_remaining == 0 or sell_remaining == 0:
                return False
                
            ratio = max(buy_remaining, sell_remaining) / min(buy_remaining, sell_remaining)
            
            return ratio <= 2.5  # ‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 2.5:1
            
        except:
            return False
    
    def is_optimal_close_timing(self, pair) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏ó‡∏µ‡πà‡∏î‡∏µ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÑ‡∏´‡∏°"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö market volatility
            volatility = self.get_current_volatility()
            
            # ‡∏ñ‡πâ‡∏≤ volatility ‡∏™‡∏π‡∏á ‡πÉ‡∏´‡πâ‡∏£‡∏≠
            if volatility > 15:  # ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 15 points per minute
                return False
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö profit stability
            for pos in pair.get('profitable_positions', []):
                if hasattr(pos, 'max_profit_seen'):
                    # ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡πÑ‡∏£‡∏•‡∏î‡∏•‡∏á‡∏à‡∏≤‡∏Å peak ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 30%
                    if pos.pnl < pos.max_profit_seen * 0.7:
                        return False
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ - ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡πà‡∏≤‡∏ß‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
            current_hour = datetime.now().hour
            if current_hour in [8, 9, 14, 15, 21, 22]:  # ‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡πà‡∏≤‡∏ß‡∏´‡∏•‡∏±‡∏Å
                return False
            
            return True
            
        except:
            return True  # default ‡πÉ‡∏´‡πâ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ
    
    def confirm_optimal_close(self, pair) -> bool:
        """‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏¥‡∏î"""
        try:
            # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            current_price = self.grid_system.get_current_price()
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£‡πÉ‡∏´‡∏°‡πà‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            updated_pnl = 0
            for pos in pair.get('profitable_positions', []) + pair.get('losing_positions', []):
                if pos.direction == "BUY":
                    updated_pnl += (current_price - pos.entry_price) * pos.lot_size * 100
                else:
                    updated_pnl += (pos.entry_price - current_price) * pos.lot_size * 100
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏¢‡∏±‡∏á‡∏Ñ‡∏∏‡πâ‡∏°‡∏Ñ‡πà‡∏≤‡πÑ‡∏´‡∏°
            if updated_pnl < pair['net_profit'] * 0.8:  # ‡∏•‡∏î‡∏•‡∏á‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 20%
                print(f"   ‚ö†Ô∏è Profit reduced, skipping close: ${updated_pnl:.2f} vs ${pair['net_profit']:.2f}")
                return False
            
            return True
            
        except:
            return True
    
    def analyze_market_timing(self) -> Dict:
        """‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏†‡∏≤‡∏ß‡∏∞‡∏ï‡∏•‡∏≤‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö timing"""
        try:
            current_price = self.grid_system.get_current_price()
            
            # ‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏£‡∏≤‡∏Ñ‡∏≤ 10 ‡∏ô‡∏≤‡∏ó‡∏µ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            price_history = self.grid_system.price_history[-10:] if hasattr(self.grid_system, 'price_history') else []
            
            if len(price_history) < 5:
                return {'condition': 'UNKNOWN', 'volatility': 0, 'trend': 'SIDEWAYS'}
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì volatility
            price_changes = [abs(price_history[i] - price_history[i-1]) for i in range(1, len(price_history))]
            avg_volatility = sum(price_changes) / len(price_changes) if price_changes else 0
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì trend
            price_diff = price_history[-1] - price_history[0]
            if price_diff > 0.5:
                trend = 'UPTREND'
            elif price_diff < -0.5:
                trend = 'DOWNTREND'
            else:
                trend = 'SIDEWAYS'
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏†‡∏≤‡∏ß‡∏∞
            if avg_volatility > 1.0:
                condition = 'HIGH_VOLATILITY'
            elif avg_volatility < 0.3:
                condition = 'LOW_VOLATILITY'
            else:
                condition = 'NORMAL'
            
            return {
                'condition': condition,
                'volatility': avg_volatility,
                'trend': trend,
                'recommendation': self.get_timing_recommendation(condition, trend)
            }
            
        except:
            return {'condition': 'UNKNOWN', 'volatility': 0, 'trend': 'SIDEWAYS', 'recommendation': 'NORMAL'}
    
    def get_timing_recommendation(self, condition, trend) -> str:
        """‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ timing strategy"""
        if condition == 'HIGH_VOLATILITY':
            return 'WAIT'  # ‡∏£‡∏≠‡πÉ‡∏´‡πâ volatility ‡∏•‡∏î‡∏•‡∏á
        elif condition == 'LOW_VOLATILITY' and trend == 'SIDEWAYS':
            return 'AGGRESSIVE'  # ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏õ‡∏¥‡∏î‡πÄ‡∏Å‡πá‡∏ö‡∏Å‡∏≥‡πÑ‡∏£
        elif trend in ['UPTREND', 'DOWNTREND']:
            return 'SELECTIVE'  # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏¥‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡πâ‡∏°‡∏Ñ‡πà‡∏≤
        else:
            return 'NORMAL'
    
    def adjust_close_timing_by_market(self, market_condition, positions):
        """‡∏õ‡∏£‡∏±‡∏ö timing ‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏ß‡∏∞‡∏ï‡∏•‡∏≤‡∏î"""
        try:
            recommendation = market_condition.get('recommendation', 'NORMAL')
            
            if recommendation == 'WAIT':
                print("‚è∏Ô∏è Market timing: Waiting for better conditions")
                return
            elif recommendation == 'AGGRESSIVE':
                print("üöÄ Market timing: Aggressive profit taking")
                # ‡∏•‡∏î threshold ‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î
                self.temporary_profit_threshold = 1.5
            elif recommendation == 'SELECTIVE':
                print("üéØ Market timing: Selective closing")
                # ‡πÄ‡∏û‡∏¥‡πà‡∏° threshold ‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î
                self.temporary_profit_threshold = 4.0
            else:
                print("üìä Market timing: Normal operations")
                self.temporary_profit_threshold = 2.5
                
        except Exception as e:
            print(f"‚ùå Market timing adjustment error: {e}")
    
    def get_current_volatility(self) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì volatility ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        try:
            if not hasattr(self.grid_system, 'price_history'):
                return 5.0  # default volatility
                
            recent_prices = self.grid_system.price_history[-5:]  # 5 ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            
            if len(recent_prices) < 2:
                return 5.0
                
            price_changes = [abs(recent_prices[i] - recent_prices[i-1]) / 0.01 
                           for i in range(1, len(recent_prices))]
            
            return sum(price_changes) / len(price_changes) if price_changes else 5.0
            
        except:
            return 5.0
        
    def find_critical_gaps_near_market(self, current_price) -> Dict:
        """‡∏´‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏Å‡∏•‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ï‡∏¥‡∏° - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç Method"""
        try:
            # ‚úÖ ‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô AIGoldGrid
            pending_orders = self.grid_system.get_pending_orders()
            
            if not pending_orders:
                print("üìã No pending orders found, creating default gaps")
                return {
                    'buy_gaps': [{
                        'price': current_price - (200 * 0.01),
                        'gap_size': 999,
                        'reason': 'No pending orders exist'
                    }],
                    'sell_gaps': [{
                        'price': current_price + (200 * 0.01),
                        'gap_size': 999,
                        'reason': 'No pending orders exist'
                    }]
                }
            
            buy_orders = [o for o in pending_orders if o.get('direction') == 'BUY']
            sell_orders = [o for o in pending_orders if o.get('direction') == 'SELL']
            
            gaps = {'buy_gaps': [], 'sell_gaps': []}
            critical_distance = 200  # 200 points ‡∏à‡∏≤‡∏Å‡∏ï‡∏•‡∏≤‡∏î
            
            # ‡∏´‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á BUY ‡πÉ‡∏Å‡∏•‡πâ‡∏ï‡∏•‡∏≤‡∏î
            if buy_orders:
                buy_prices = sorted([o['price'] for o in buy_orders], reverse=True)
                nearest_buy = buy_prices[0]
                gap_distance = (current_price - nearest_buy) / 0.01
                
                if gap_distance > critical_distance:
                    gaps['buy_gaps'].append({
                        'price': current_price - (critical_distance * 0.01),
                        'gap_size': gap_distance,
                        'reason': f'Critical gap: {gap_distance:.0f} points from nearest BUY'
                    })
            else:
                # ‡πÑ‡∏°‡πà‡∏°‡∏µ BUY orders ‡πÄ‡∏•‡∏¢
                gaps['buy_gaps'].append({
                    'price': current_price - (critical_distance * 0.01),
                    'gap_size': 999,
                    'reason': 'No BUY orders exist'
                })
            
            # ‡∏´‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á SELL ‡πÉ‡∏Å‡∏•‡πâ‡∏ï‡∏•‡∏≤‡∏î
            if sell_orders:
                sell_prices = sorted([o['price'] for o in sell_orders])
                nearest_sell = sell_prices[0]
                gap_distance = (nearest_sell - current_price) / 0.01
                
                if gap_distance > critical_distance:
                    gaps['sell_gaps'].append({
                        'price': current_price + (critical_distance * 0.01),
                        'gap_size': gap_distance,
                        'reason': f'Critical gap: {gap_distance:.0f} points from nearest SELL'
                    })
            else:
                # ‡πÑ‡∏°‡πà‡∏°‡∏µ SELL orders ‡πÄ‡∏•‡∏¢
                gaps['sell_gaps'].append({
                    'price': current_price + (critical_distance * 0.01),
                    'gap_size': 999,
                    'reason': 'No SELL orders exist'
                })
            
            print(f"üîç Found gaps: {len(gaps['buy_gaps'])} BUY, {len(gaps['sell_gaps'])} SELL")
            return gaps
            
        except Exception as e:
            print(f"‚ùå Find critical gaps error: {e}")
            # Return safe default gaps
            return {
                'buy_gaps': [{
                    'price': current_price - (200 * 0.01),
                    'gap_size': 200,
                    'reason': 'Error fallback - default BUY gap'
                }],
                'sell_gaps': [{
                    'price': current_price + (200 * 0.01),
                    'gap_size': 200,
                    'reason': 'Error fallback - default SELL gap'
                }]
            }
    
    def add_sell_orders_for_balance(self, current_price, count):
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method - ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á"""
        try:
            tight_spacing = 150  # 150 ‡∏à‡∏∏‡∏î
            
            for i in range(min(count, 3)):  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 3 ‡∏ï‡∏±‡∏ß
                price = current_price + (tight_spacing * (i + 1) * 0.01)
                
                # ‚úÖ ‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
                if not self.grid_system.has_nearby_order(price, "SELL"):
                    lot_size = self.grid_system.base_lot
                    success = self.grid_system.place_smart_rebalance_order("SELL", price, lot_size)
                    if success:
                        print(f"   ‚úÖ Balance SELL: {lot_size:.3f} @ ${price:.2f}")
                        
        except Exception as e:
            print(f"‚ùå Balance SELL orders error: {e}")

    def add_buy_orders_for_balance(self, current_price, count):
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç method - ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á"""
        try:
            tight_spacing = 150  # 150 ‡∏à‡∏∏‡∏î
            
            for i in range(min(count, 3)):  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 3 ‡∏ï‡∏±‡∏ß
                price = current_price - (tight_spacing * (i + 1) * 0.01)
                
                # ‚úÖ ‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
                if not self.grid_system.has_nearby_order(price, "BUY"):
                    lot_size = self.grid_system.base_lot
                    success = self.grid_system.place_smart_rebalance_order("BUY", price, lot_size)
                    if success:
                        print(f"   ‚úÖ Balance BUY: {lot_size:.3f} @ ${price:.2f}")
                        
        except Exception as e:
            print(f"‚ùå Balance BUY orders error: {e}")


    def smart_rebalance_with_checks(self, positions):
        """Rebalancing ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏â‡∏•‡∏≤‡∏î - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡πâ aggressive ‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°"""
        try:
            current_price = self.grid_system.get_current_price()
            buy_count = len([p for p in positions if p.direction == "BUY"])
            sell_count = len([p for p in positions if p.direction == "SELL"])
            
            print(f"üìä Smart Check: {buy_count} BUY, {sell_count} SELL @ ${current_price:.2f}")
            
            # ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ existing orders ‡∏Å‡πà‡∏≠‡∏ô
            existing_orders = self.get_all_existing_orders()
            buy_orders = [o for o in existing_orders if o['direction'] == "BUY"]
            sell_orders = [o for o in existing_orders if o['direction'] == "SELL"]
            
            total_coverage = len(buy_orders) + len(sell_orders) + len(positions)
            print(f"üìã Total coverage: {total_coverage} ({len(positions)} positions + {len(existing_orders)} orders)")
            
            # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏•‡∏î‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç coverage ‡∏à‡∏≤‡∏Å 8 ‡πÄ‡∏õ‡πá‡∏ô 6
            if total_coverage >= 6 and abs(buy_count - sell_count) <= 1:
                print("   ‚úÖ Sufficient coverage - no rebalancing needed")
                return
                
            # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: Balance check ‡πÑ‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô - ‡∏ñ‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô > 1 (‡πÅ‡∏ó‡∏ô > 2)
            if abs(buy_count - sell_count) > 1:
                imbalance = buy_count - sell_count
                print(f"‚öñÔ∏è Portfolio imbalance detected: {imbalance}")
                self.fix_portfolio_imbalance_aggressive(current_price, imbalance, existing_orders)
                return
                
            # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡πÄ‡∏ä‡πá‡∏Ñ extreme imbalance (‡πÄ‡∏ä‡πà‡∏ô 0 BUY vs 3 SELL)
            if buy_count == 0 and sell_count > 0:
                print(f"üö® EXTREME: No BUY positions vs {sell_count} SELL - Force adding BUY orders")
                self.force_add_buy_orders(current_price, min(sell_count, 3))
                return
                
            if sell_count == 0 and buy_count > 0:
                print(f"üö® EXTREME: No SELL positions vs {buy_count} BUY - Force adding SELL orders")
                self.force_add_sell_orders(current_price, min(buy_count, 3))
                return
            
            # ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ gaps ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏° orders
            gaps = self.find_significant_gaps(current_price, existing_orders + positions)
            
            if gaps['buy_gaps']:
                print(f"üîç Found BUY gaps: {len(gaps['buy_gaps'])} locations")
                self.fill_specific_gaps(gaps['buy_gaps'], "BUY")
                
            if gaps['sell_gaps']:
                print(f"üîç Found SELL gaps: {len(gaps['sell_gaps'])} locations")
                self.fill_specific_gaps(gaps['sell_gaps'], "SELL")
                
        except Exception as e:
            print(f"‚ùå Smart rebalance error: {e}")

    def fix_portfolio_imbalance_aggressive(self, current_price, imbalance, existing_orders):
        """‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç portfolio imbalance ‡πÅ‡∏ö‡∏ö aggressive"""
        try:
            if imbalance < 0:  # SELL ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ BUY
                needed_buy = abs(imbalance)
                print(f"üîÑ Adding {needed_buy} BUY orders to balance SELL heavy portfolio")
                self.force_add_buy_orders(current_price, needed_buy)
            else:  # BUY ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ SELL  
                needed_sell = abs(imbalance)
                print(f"üîÑ Adding {needed_sell} SELL orders to balance BUY heavy portfolio")
                self.force_add_sell_orders(current_price, needed_sell)
                
        except Exception as e:
            print(f"‚ùå Aggressive imbalance fix error: {e}")

    def force_add_buy_orders(self, current_price, count):
        """‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏° BUY orders"""
        try:
            spacing = 120  # ‡πÉ‡∏ä‡πâ spacing ‡πÄ‡∏•‡πá‡∏Å 120 ‡∏à‡∏∏‡∏î
            
            for i in range(min(count, 4)):  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 4 ‡∏ï‡∏±‡∏ß
                price = current_price - (spacing * (i + 1) * 0.01)
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏Å‡∏•‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡πÑ‡∏´‡∏°
                distance = (current_price - price) / 0.01
                if distance > 600:  # ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 600 ‡∏à‡∏∏‡∏î
                    print(f"   ‚ö†Ô∏è BUY order too far: {distance:.0f} points")
                    continue
                    
                if not self.grid_system.has_nearby_order(price, "BUY"):
                    success = self.grid_system.place_smart_rebalance_order("BUY", price, self.grid_system.base_lot)
                    if success:
                        print(f"   üöÄ Force BUY: 0.01 @ ${price:.2f} ({distance:.0f} pts)")
                        
        except Exception as e:
            print(f"‚ùå Force BUY orders error: {e}")

    def force_add_sell_orders(self, current_price, count):
        """‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏° SELL orders"""
        try:
            spacing = 120  # ‡πÉ‡∏ä‡πâ spacing ‡πÄ‡∏•‡πá‡∏Å 120 ‡∏à‡∏∏‡∏î
            
            for i in range(min(count, 4)):  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 4 ‡∏ï‡∏±‡∏ß
                price = current_price + (spacing * (i + 1) * 0.01)
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏Å‡∏•‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡πÑ‡∏´‡∏°
                distance = (price - current_price) / 0.01
                if distance > 600:  # ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 600 ‡∏à‡∏∏‡∏î
                    print(f"   ‚ö†Ô∏è SELL order too far: {distance:.0f} points")
                    continue
                    
                if not self.grid_system.has_nearby_order(price, "SELL"):
                    success = self.grid_system.place_smart_rebalance_order("SELL", price, self.grid_system.base_lot)
                    if success:
                        print(f"   üöÄ Force SELL: 0.01 @ ${price:.2f} ({distance:.0f} pts)")
                        
        except Exception as e:
            print(f"‚ùå Force SELL orders error: {e}")


    def get_all_existing_orders(self):
        """‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏° orders ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà"""
        try:
            all_orders = []
            
            # Pending orders
            for order in self.grid_system.pending_orders.values():
                all_orders.append({
                    'price': order.price,
                    'direction': order.direction,
                    'type': 'pending',
                    'lot_size': order.lot_size
                })
                
            # Active positions
            for pos in self.grid_system.active_positions.values():
                all_orders.append({
                    'price': pos.price,
                    'direction': pos.direction,
                    'type': 'active',
                    'lot_size': pos.lot_size
                })
                
            return all_orders
            
        except Exception as e:
            print(f"‚ùå Get existing orders error: {e}")
            return []

    def find_significant_gaps(self, current_price, existing_orders):
        """‡∏´‡∏≤ gaps ‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏à‡∏£‡∏¥‡∏á‡πÜ"""
        try:
            buy_orders = [o for o in existing_orders if o['direction'] == "BUY"]
            sell_orders = [o for o in existing_orders if o['direction'] == "SELL"]
            
            gaps = {'buy_gaps': [], 'sell_gaps': []}
            significant_gap = 250  # ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏ç‡πà‡∏à‡∏£‡∏¥‡∏á‡πÜ (250 ‡∏à‡∏∏‡∏î)
            
            # ‡πÄ‡∏ä‡πá‡∏Ñ BUY gaps
            if buy_orders:
                buy_prices = sorted([o['price'] for o in buy_orders], reverse=True)
                
                # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á current price ‡∏Å‡∏±‡∏ö order ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                nearest_buy = buy_prices[0]
                gap_to_current = (current_price - nearest_buy) / 0.01
                
                if gap_to_current > significant_gap:
                    target_price = current_price - (150 * 0.01)  # ‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà 150 ‡∏à‡∏∏‡∏î
                    gaps['buy_gaps'].append({
                        'price': target_price,
                        'gap_size': gap_to_current,
                        'reason': f'Gap to current: {gap_to_current:.0f} points'
                    })
            else:
                # ‡πÑ‡∏°‡πà‡∏°‡∏µ BUY orders ‡πÄ‡∏•‡∏¢
                gaps['buy_gaps'].append({
                    'price': current_price - (150 * 0.01),
                    'gap_size': 999,
                    'reason': 'No BUY orders exist'
                })
                
            # ‡πÄ‡∏ä‡πá‡∏Ñ SELL gaps
            if sell_orders:
                sell_prices = sorted([o['price'] for o in sell_orders])
                
                nearest_sell = sell_prices[0]
                gap_to_current = (nearest_sell - current_price) / 0.01
                
                if gap_to_current > significant_gap:
                    target_price = current_price + (150 * 0.01)
                    gaps['sell_gaps'].append({
                        'price': target_price,
                        'gap_size': gap_to_current,
                        'reason': f'Gap to current: {gap_to_current:.0f} points'
                    })
            else:
                # ‡πÑ‡∏°‡πà‡∏°‡∏µ SELL orders ‡πÄ‡∏•‡∏¢
                gaps['sell_gaps'].append({
                    'price': current_price + (150 * 0.01),
                    'gap_size': 999,
                    'reason': 'No SELL orders exist'
                })
                
            return gaps
            
        except Exception as e:
            print(f"‚ùå Find gaps error: {e}")
            return {'buy_gaps': [], 'sell_gaps': []}

    def fill_specific_gaps(self, gaps, direction):
        """‡πÄ‡∏ï‡∏¥‡∏°‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô"""
        try:
            for gap in gaps[:2]:  # ‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 2 ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á
                price = gap['price']
                
                # ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡∏≤‡∏á
                if not self.grid_system.has_nearby_order(price, direction):
                    success = self.grid_system.place_smart_rebalance_order(direction, price, self.grid_system.base_lot)
                    if success:
                        print(f"   üîß Filled {direction} gap @ ${price:.2f} ({gap['reason']})")
                        
        except Exception as e:
            print(f"‚ùå Fill specific gaps error: {e}")

            
    def find_profitable_pairs(self, positions):
        """üß† AI INTELLIGENT CLOSING - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å method ‡πÄ‡∏î‡∏¥‡∏°"""
        try:
            if not positions:
                return []
                
            current_price = self.grid_system.get_current_price()
            account_info = self.grid_system.mt5_connector.get_account_info()
            current_margin_level = account_info.get('margin_level', 0) if account_info else 0
            
            print(f"üß† AI ANALYSIS: {len(positions)} positions @ ${current_price:.2f} (Margin: {current_margin_level:.1f}%)")
            
            # üéØ ‡∏à‡∏±‡∏î‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏â‡∏•‡∏≤‡∏î
            buy_positions = [p for p in positions if p.direction == "BUY"]
            sell_positions = [p for p in positions if p.direction == "SELL"]
            
            hedging_positions = []      # ‡πÑ‡∏°‡πâ‡∏Ñ‡πâ‡∏≥‡∏û‡∏≠‡∏£‡πå‡∏ï
            profit_generators = []      # ‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏î‡∏µ  
            losing_positions = []       # ‡πÑ‡∏°‡πâ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
            dead_weight = []           # ‡πÑ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå
            
            # üß† ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÑ‡∏°‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß
            for pos in positions:
                distance_from_market = abs(pos.entry_price - current_price) / 0.01  # points
                
                # üõ°Ô∏è ‡πÑ‡∏°‡πâ‡∏Ñ‡πâ‡∏≥‡∏û‡∏≠‡∏£‡πå‡∏ï = ‡∏≠‡∏¢‡∏π‡πà‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏ï‡∏•‡∏≤‡∏î > 500 points ‡πÅ‡∏•‡∏∞‡∏°‡∏µ potential ‡∏Å‡∏≥‡πÑ‡∏£
                if distance_from_market > 500:
                    potential_profit = 0
                    if pos.direction == "BUY" and current_price < pos.entry_price:
                        potential_profit = (pos.entry_price - current_price) * pos.lot_size * 100
                    elif pos.direction == "SELL" and current_price > pos.entry_price:
                        potential_profit = (current_price - pos.entry_price) * pos.lot_size * 100
                    
                    if potential_profit > 5:  # ‡∏°‡∏µ potential > $5
                        hedging_positions.append(pos)
                        print(f"   üõ°Ô∏è HEDGE: {pos.direction} @ ${pos.entry_price:.2f} (${pos.pnl:.2f}) - Potential: +${potential_profit:.2f}")
                        continue
                
                # üí∞ ‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏î‡∏µ = ‡∏Å‡∏≥‡πÑ‡∏£ > $2 ‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ï‡∏•‡∏≤‡∏î
                if pos.pnl > 2 and distance_from_market < 300:
                    profit_generators.append(pos)
                    print(f"   üí∞ PROFIT GEN: {pos.direction} @ ${pos.entry_price:.2f} (+${pos.pnl:.2f})")
                    continue
                
                # üìâ ‡πÑ‡∏°‡πâ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô = ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô > $1
                elif pos.pnl < -1:
                    losing_positions.append(pos)
                    print(f"   üìâ LOSING: {pos.direction} @ ${pos.entry_price:.2f} (${pos.pnl:.2f})")
                    continue
                
                # üóëÔ∏è ‡πÑ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå = ‡∏Å‡∏≥‡πÑ‡∏£‡∏ô‡πâ‡∏≠‡∏¢ ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏Ñ‡πâ‡∏≥‡∏û‡∏≠‡∏£‡πå‡∏ï
                else:
                    dead_weight.append(pos)
                    print(f"   üóëÔ∏è DEAD WEIGHT: {pos.direction} @ ${pos.entry_price:.2f} (${pos.pnl:.2f})")
            
            print(f"üìä Classification: üõ°Ô∏è{len(hedging_positions)} üí∞{len(profit_generators)} üìâ{len(losing_positions)} üóëÔ∏è{len(dead_weight)}")
            
            smart_pairs = []
            
            # üéØ STRATEGY 1: ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏î‡∏µ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
            for profit_pos in profit_generators:
                for loss_pos in losing_positions:
                    net_pnl = profit_pos.pnl + loss_pos.pnl
                    margin_freed = (profit_pos.lot_size + loss_pos.lot_size) * 500  # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏Å‡∏≤‡∏£ margin
                    
                    if net_pnl > -1:  # ‡∏¢‡∏≠‡∏°‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏™‡∏∏‡∏ó‡∏ò‡∏¥‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô $1
                        smart_pairs.append({
                            'losing_positions': [loss_pos],
                            'profitable_positions': [profit_pos],
                            'net_profit': net_pnl,
                            'total_positions': 2,
                            'pair_type': "SMART_RECOVERY",
                            'priority_score': 2000 + abs(loss_pos.pnl) + margin_freed/100,  # Priority ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
                            'position_ids': {profit_pos.position_id, loss_pos.position_id},
                            'margin_impact': f"+${margin_freed:.0f} freed",
                            'reason': f"Use profit ${profit_pos.pnl:.2f} to close loss ${loss_pos.pnl:.2f}"
                        })
                        print(f"   üéØ SMART RECOVERY: Use +${profit_pos.pnl:.2f} to close ${loss_pos.pnl:.2f} = ${net_pnl:.2f}")
            
            # üéØ STRATEGY 2: ‡∏õ‡∏¥‡∏î Dead Weight ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
            for dead_pos in dead_weight:
                if dead_pos.pnl > 0.5:  # ‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏•‡πá‡∏Å‡πÜ
                    smart_pairs.append({
                        'losing_positions': [],
                        'profitable_positions': [dead_pos],
                        'net_profit': dead_pos.pnl,
                        'total_positions': 1,
                        'pair_type': "CLEANUP_PROFIT",
                        'priority_score': 1500 + dead_pos.pnl,
                        'position_ids': {dead_pos.position_id},
                        'margin_impact': f"+${dead_pos.lot_size * 500:.0f} freed",
                        'reason': f"Clean small profit ${dead_pos.pnl:.2f} + free margin"
                    })
                    print(f"   üßπ CLEANUP: Small profit ${dead_pos.pnl:.2f} + margin free")
            
            # üéØ STRATEGY 3: ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà‡∏Å‡∏≥‡πÑ‡∏£‡∏õ‡∏Å‡∏ï‡∏¥ (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ recovery opportunities)
            if len(smart_pairs) < 2:  # ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà‡∏î‡∏µ‡πÜ
                for buy_pos in buy_positions:
                    for sell_pos in sell_positions:
                        # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÑ‡∏°‡πâ‡∏Ñ‡πâ‡∏≥‡∏û‡∏≠‡∏£‡πå‡∏ï
                        if buy_pos in hedging_positions or sell_pos in hedging_positions:
                            continue
                            
                        net_pnl = buy_pos.pnl + sell_pos.pnl
                        
                        if net_pnl > 1.2:  # threshold ‡∏õ‡∏Å‡∏ï‡∏¥
                            margin_freed = (buy_pos.lot_size + sell_pos.lot_size) * 500
                            
                            smart_pairs.append({
                                'losing_positions': [buy_pos if buy_pos.pnl < 0 else sell_pos] if min(buy_pos.pnl, sell_pos.pnl) < 0 else [],
                                'profitable_positions': [buy_pos if buy_pos.pnl > 0 else sell_pos] if max(buy_pos.pnl, sell_pos.pnl) > 0 else [buy_pos, sell_pos],
                                'net_profit': net_pnl,
                                'total_positions': 2,
                                'pair_type': "STANDARD_PROFIT",
                                'priority_score': 1000 + net_pnl,
                                'position_ids': {buy_pos.position_id, sell_pos.position_id},
                                'margin_impact': f"+${margin_freed:.0f} freed",
                                'reason': f"Standard pair profit"
                            })
                            print(f"   üí∞ STANDARD: {buy_pos.direction}(${buy_pos.pnl:.2f}) + {sell_pos.direction}(${sell_pos.pnl:.2f}) = +${net_pnl:.2f}")
            
            # üéØ STRATEGY 4: Emergency margin relief (‡∏ñ‡πâ‡∏≤ margin ‡∏ï‡πà‡∏≥)
            if current_margin_level < 200:
                print(f"üö® LOW MARGIN ({current_margin_level:.1f}%) - Emergency margin relief")
                
                # ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ margin ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                high_margin_positions = sorted(positions, key=lambda x: x.lot_size, reverse=True)[:3]
                
                for pos in high_margin_positions:
                    if pos not in hedging_positions and pos.pnl > -2:  # ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà hedge ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏°‡∏≤‡∏Å
                        margin_freed = pos.lot_size * 500
                        
                        smart_pairs.append({
                            'losing_positions': [pos] if pos.pnl < 0 else [],
                            'profitable_positions': [pos] if pos.pnl > 0 else [],
                            'net_profit': pos.pnl,
                            'total_positions': 1,
                            'pair_type': "EMERGENCY_MARGIN",
                            'priority_score': 2500 + margin_freed/100,  # Priority ‡∏™‡∏π‡∏á‡∏°‡∏≤‡∏Å
                            'position_ids': {pos.position_id},
                            'margin_impact': f"+${margin_freed:.0f} CRITICAL margin relief",
                            'reason': f"Emergency: Free {margin_freed:.0f} margin"
                        })
                        print(f"   üö® EMERGENCY: Close {pos.direction}(${pos.pnl:.2f}) to free ${margin_freed:.0f} margin")
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° priority
            smart_pairs.sort(key=lambda x: x['priority_score'], reverse=True)
            
            # ‡∏Å‡∏£‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ã‡πâ‡∏≥
            final_pairs = self.select_non_overlapping_pairs(smart_pairs)
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå
            if final_pairs:
                print(f"üéØ AI DECISION: {len(final_pairs)} intelligent actions selected")
                for i, pair in enumerate(final_pairs[:3]):
                    print(f"   {i+1}. {pair['pair_type']}: {pair['reason']} ‚Üí {pair['margin_impact']}")
                    
                # üõ°Ô∏è ‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ñ‡πâ‡∏≤‡∏à‡∏∞‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡∏Ñ‡πâ‡∏≥‡∏û‡∏≠‡∏£‡πå‡∏ï
                hedging_ids = {pos.position_id for pos in hedging_positions}
                for pair in final_pairs:
                    if hedging_ids.intersection(pair['position_ids']):
                        print(f"   ‚ö†Ô∏è WARNING: Pair contains hedging position - reconsider!")
            else:
                print("ü§î AI DECISION: No intelligent closing opportunities found")
                print(f"   üí° Keeping {len(hedging_positions)} hedge positions")
                print(f"   üí° Monitoring {len(profit_generators)} profit generators")
            
            return final_pairs
            
        except Exception as e:
            print(f"‚ùå AI analysis error: {e}")
            return []

    def find_wrong_side_pairs(self, buy_positions, sell_positions, current_price):
        """üö® ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏ú‡∏¥‡∏î‡∏Ç‡πâ‡∏≤‡∏á‡∏ï‡∏•‡∏≤‡∏î (Priority ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î)"""
        wrong_pairs = []
        
        # BUY ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏ï‡∏•‡∏≤‡∏î (‡∏ú‡∏¥‡∏î)
        wrong_buys = [b for b in buy_positions if b.entry_price > current_price and b.pnl < -2]
        # SELL ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ï‡πâ‡∏ï‡∏•‡∏≤‡∏î (‡∏ú‡∏¥‡∏î)  
        wrong_sells = [s for s in sell_positions if s.entry_price < current_price and s.pnl < -2]
        
        # ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏°‡πâ‡∏ú‡∏¥‡∏î‡∏Ç‡πâ‡∏≤‡∏á‡∏Å‡∏±‡∏ö‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£
        all_good_positions = [p for p in buy_positions + sell_positions if p.pnl > 0.5]
        
        for wrong_pos in wrong_buys + wrong_sells:
            for good_pos in all_good_positions:
                net_pnl = wrong_pos.pnl + good_pos.pnl
                
                if net_pnl > -1.0:  # ‡∏¢‡∏≠‡∏°‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ portfolio
                    wrong_pairs.append({
                        'losing_positions': [wrong_pos],
                        'profitable_positions': [good_pos] if good_pos.pnl > 0 else [],
                        'net_profit': net_pnl,
                        'total_positions': 2,
                        'pair_type': "WRONG_SIDE_FIX",
                        'priority_score': 2000 + abs(wrong_pos.pnl),  # Priority ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
                        'position_ids': {wrong_pos.position_id, good_pos.position_id}
                    })
        
        return wrong_pairs
    
    def find_margin_efficient_pairs(self, buy_positions, sell_positions):
        """üí™ ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏î margin load ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î"""
        margin_pairs = []
        
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì margin impact ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ position  
        for buy_pos in buy_positions:
            for sell_pos in sell_positions:
                net_pnl = buy_pos.pnl + sell_pos.pnl
                
                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì margin ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏Ñ‡∏∑‡∏ô
                margin_released = (buy_pos.lot_size + sell_pos.lot_size) * 1000  # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏Å‡∏≤‡∏£
                
                # ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ ‡∏´‡∏£‡∏∑‡∏≠ margin efficiency ‡∏î‡∏µ
                efficiency_score = (net_pnl + 5) + (margin_released * 0.01)  # bonus ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö margin release
                
                if net_pnl > -2 and efficiency_score > 8:  # threshold ‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ
                    margin_pairs.append({
                        'losing_positions': [buy_pos if buy_pos.pnl < 0 else sell_pos] if min(buy_pos.pnl, sell_pos.pnl) < 0 else [],
                        'profitable_positions': [buy_pos if buy_pos.pnl > 0 else sell_pos] if max(buy_pos.pnl, sell_pos.pnl) > 0 else [],
                        'net_profit': net_pnl,
                        'total_positions': 2,
                        'pair_type': "MARGIN_EFFICIENT",
                        'priority_score': 1500 + efficiency_score,
                        'position_ids': {buy_pos.position_id, sell_pos.position_id},
                        'margin_released': margin_released
                    })
        
        return margin_pairs
    
    def find_balanced_pairs(self, buy_positions, sell_positions):
        """üéØ ‡∏Ñ‡∏π‡πà‡∏Å‡∏≥‡πÑ‡∏£‡∏õ‡∏Å‡∏ï‡∏¥ (threshold ‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ß)"""
        balanced_pairs = []
        
        for buy_pos in buy_positions:
            for sell_pos in sell_positions:
                net_pnl = buy_pos.pnl + sell_pos.pnl
                
                # ‡πÄ‡∏û‡∏¥‡πà‡∏° threshold ‡∏à‡∏≤‡∏Å $0.1 ‡πÄ‡∏õ‡πá‡∏ô $2.5 (‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ß)
                if net_pnl > 2.5:
                    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏π‡πà
                    pair_quality = net_pnl
                    if min(buy_pos.pnl, sell_pos.pnl) > 0:  # ‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏π‡πà‡∏Å‡∏≥‡πÑ‡∏£
                        pair_quality *= 1.5
                    
                    balanced_pairs.append({
                        'losing_positions': [buy_pos if buy_pos.pnl < sell_pos.pnl else sell_pos],
                        'profitable_positions': [sell_pos if buy_pos.pnl < sell_pos.pnl else buy_pos],
                        'net_profit': net_pnl,
                        'total_positions': 2,
                        'pair_type': "BALANCED_PROFIT",
                        'priority_score': 800 + pair_quality,
                        'position_ids': {buy_pos.position_id, sell_pos.position_id}
                    })
        
        return balanced_pairs
    
    def find_balance_correction_pairs(self, buy_positions, sell_positions):
        """‚öñÔ∏è ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç BUY:SELL ratio ‡πÉ‡∏´‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•"""
        balance_pairs = []
        
        buy_count = len(buy_positions)
        sell_count = len(sell_positions)
        imbalance = abs(buy_count - sell_count)
        
        # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏°‡∏î‡∏∏‡∏•‡πÄ‡∏Å‡∏¥‡∏ô 3 positions
        if imbalance <= 3:
            return []
        
        # ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•
        if buy_count > sell_count:  # BUY ‡πÄ‡∏¢‡∏≠‡∏∞‡πÄ‡∏Å‡∏¥‡∏ô
            # ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ BUY ‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß + SELL ‡∏ô‡πâ‡∏≠‡∏¢‡∏ï‡∏±‡∏ß
            excess_buys = sorted(buy_positions, key=lambda x: x.pnl, reverse=True)[:imbalance//2]
            for buy_pos in excess_buys:
                for sell_pos in sell_positions:
                    net_pnl = buy_pos.pnl + sell_pos.pnl
                    if net_pnl > 1.0:  # threshold ‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•
                        balance_pairs.append({
                            'losing_positions': [buy_pos if buy_pos.pnl < 0 else sell_pos] if min(buy_pos.pnl, sell_pos.pnl) < 0 else [],
                            'profitable_positions': [buy_pos if buy_pos.pnl > 0 else sell_pos] if max(buy_pos.pnl, sell_pos.pnl) > 0 else [],
                            'net_profit': net_pnl,
                            'total_positions': 2,
                            'pair_type': "BALANCE_CORRECTION",
                            'priority_score': 600 + net_pnl + imbalance,  # bonus ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö balance
                            'position_ids': {buy_pos.position_id, sell_pos.position_id}
                        })
        
        return balance_pairs
    
    def get_portfolio_health_score(self, positions) -> Dict:
        """üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Portfolio Health Score"""
        try:
            if not positions:
                return {'score': 0, 'status': 'NO_POSITIONS', 'issues': []}
            
            current_price = self.grid_system.get_current_price()
            buy_positions = [p for p in positions if p.direction == "BUY"]
            sell_positions = [p for p in positions if p.direction == "SELL"]
            
            health_score = 100  # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà 100
            issues = []
            
            # 1. Balance Score (20 points)
            balance_ratio = len(buy_positions) / len(sell_positions) if sell_positions else 999
            if balance_ratio > 2 or balance_ratio < 0.5:
                health_score -= 20
                issues.append(f"Imbalanced BUY:SELL ratio ({len(buy_positions)}:{len(sell_positions)})")
            elif balance_ratio > 1.5 or balance_ratio < 0.67:
                health_score -= 10
                issues.append("Slightly imbalanced positions")
            
            # 2. Wrong Side Score (30 points)
            wrong_buys = len([b for b in buy_positions if b.entry_price > current_price])
            wrong_sells = len([s for s in sell_positions if s.entry_price < current_price])
            wrong_percentage = (wrong_buys + wrong_sells) / len(positions) * 100
            
            if wrong_percentage > 30:
                health_score -= 30
                issues.append(f"{wrong_percentage:.1f}% positions on wrong side")
            elif wrong_percentage > 15:
                health_score -= 15
                issues.append(f"{wrong_percentage:.1f}% positions need adjustment")
            
            # 3. PnL Distribution Score (25 points)
            total_pnl = sum(p.pnl for p in positions)
            losing_positions = len([p for p in positions if p.pnl < -2])
            losing_percentage = losing_positions / len(positions) * 100
            
            if losing_percentage > 70:
                health_score -= 25
                issues.append(f"{losing_percentage:.1f}% positions losing significantly")
            elif losing_percentage > 50:
                health_score -= 15
                issues.append("High percentage of losing positions")
            
            # 4. Margin Efficiency Score (25 points)
            large_positions = len([p for p in positions if p.lot_size > self.grid_system.base_lot * 2])
            if large_positions > len(positions) * 0.3:  # ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 30%
                health_score -= 15
                issues.append("High margin usage from large positions")
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î status
            if health_score >= 80:
                status = "EXCELLENT"
            elif health_score >= 60:
                status = "GOOD"
            elif health_score >= 40:
                status = "FAIR"
            elif health_score >= 20:
                status = "POOR"
            else:
                status = "CRITICAL"
            
            return {
                'score': max(0, health_score),
                'status': status,
                'total_pnl': total_pnl,
                'wrong_side_percentage': wrong_percentage,
                'balance_ratio': f"{len(buy_positions)}:{len(sell_positions)}",
                'losing_percentage': losing_percentage,
                'issues': issues,
                'recommendations': self.get_health_recommendations(health_score, issues)
            }
            
        except Exception as e:
            return {'score': 0, 'status': 'ERROR', 'issues': [f"Calculation error: {e}"]}
    
    def get_health_recommendations(self, score, issues) -> List[str]:
        """üí° ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á Portfolio"""
        recommendations = []
        
        if score < 40:
            recommendations.append("üö® Consider emergency portfolio cleanup")
            recommendations.append("üîÑ Close wrong-side positions immediately")
        elif score < 60:
            recommendations.append("‚öñÔ∏è Focus on balancing BUY:SELL ratio")
            recommendations.append("üí∞ Close small profitable pairs to reduce load")
        elif score < 80:
            recommendations.append("üéØ Optimize position placement")
            recommendations.append("üìä Monitor margin usage")
        else:
            recommendations.append("‚úÖ Portfolio in good condition")
            recommendations.append("üîç Continue regular monitoring")
        
        return recommendations

    def find_1_to_1_pairs(self, buy_positions, sell_positions):
        """‡∏´‡∏≤‡∏Ñ‡∏π‡πà 1:1 ‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏° (‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)"""
        pairs_1_1 = []
        
        for buy_pos in buy_positions:
            for sell_pos in sell_positions:
                net_pnl = buy_pos.pnl + sell_pos.pnl
                
                if net_pnl > 0.3:  # threshold ‡∏ï‡πà‡∏≥‡∏°‡∏≤‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 1:1
                    priority_score = net_pnl + abs(min(buy_pos.pnl, sell_pos.pnl))
                    
                    pairs_1_1.append({
                        'losing_positions': [buy_pos if buy_pos.pnl < sell_pos.pnl else sell_pos],
                        'profitable_positions': [sell_pos if buy_pos.pnl < sell_pos.pnl else buy_pos],
                        'net_profit': net_pnl,
                        'total_positions': 2,
                        'pair_type': "1:1",
                        'priority_score': priority_score,
                        'position_ids': {buy_pos.position_id, sell_pos.position_id}
                    })
        
        return pairs_1_1

    def find_1_to_n_pairs(self, buy_positions, sell_positions):
        """‡∏´‡∏≤‡∏Ñ‡∏π‡πà 1 ‡πÄ‡∏™‡∏µ‡∏¢ + 2-3 ‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£"""
        pairs_1_to_n = []
        
        # ‡∏£‡∏ß‡∏° losing positions (‡∏ó‡∏±‡πâ‡∏á BUY ‡πÅ‡∏•‡∏∞ SELL ‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏µ‡∏¢)
        losing_positions = [p for p in buy_positions + sell_positions if p.pnl < -0.5]  # ‡πÄ‡∏™‡∏µ‡∏¢‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ $0.5
        profitable_positions = [p for p in buy_positions + sell_positions if p.pnl > 0.2]  # ‡∏Å‡∏≥‡πÑ‡∏£‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ $0.2
        
        # 1 ‡πÄ‡∏™‡∏µ‡∏¢ + 2 ‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£ - ‡πÉ‡∏ä‡πâ nested loops ‡πÅ‡∏ó‡∏ô itertools
        for losing_pos in losing_positions:
            # ‡∏•‡∏≠‡∏á‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏Å‡∏±‡∏ö 2 ‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£
            for i, profit1 in enumerate(profitable_positions):
                for profit2 in profitable_positions[i+1:]:  # ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≥
                    net_pnl = losing_pos.pnl + profit1.pnl + profit2.pnl
                    
                    if net_pnl > 0.5:  # threshold ‡∏ï‡πà‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö multi-pos
                        priority_score = net_pnl + abs(losing_pos.pnl) * 0.8  # bonus ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡πÉ‡∏´‡∏ç‡πà
                        
                        pairs_1_to_n.append({
                            'losing_positions': [losing_pos],
                            'profitable_positions': [profit1, profit2],
                            'net_profit': net_pnl,
                            'total_positions': 3,
                            'pair_type': "1:2",
                            'priority_score': priority_score,
                            'position_ids': {losing_pos.position_id, profit1.position_id, profit2.position_id}
                        })
            
            # 1 ‡πÄ‡∏™‡∏µ‡∏¢ + 3 ‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£ (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÑ‡∏°‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡πÉ‡∏´‡∏ç‡πà > $3)
            if losing_pos.pnl < -3 and len(profitable_positions) >= 3:
                for i, profit1 in enumerate(profitable_positions[:5]):  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î 5 ‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å
                    for j, profit2 in enumerate(profitable_positions[i+1:5]):
                        for profit3 in profitable_positions[i+j+2:5]:
                            net_pnl = losing_pos.pnl + profit1.pnl + profit2.pnl + profit3.pnl
                            
                            if net_pnl > 0.8:
                                priority_score = net_pnl + abs(losing_pos.pnl) * 0.9
                                
                                pairs_1_to_n.append({
                                    'losing_positions': [losing_pos],
                                    'profitable_positions': [profit1, profit2, profit3],
                                    'net_profit': net_pnl,
                                    'total_positions': 4,
                                    'pair_type': "1:3",
                                    'priority_score': priority_score,
                                    'position_ids': {losing_pos.position_id, profit1.position_id, profit2.position_id, profit3.position_id}
                                })
        
        return pairs_1_to_n

    def find_n_to_1_pairs(self, buy_positions, sell_positions):
        """‡∏´‡∏≤ 2-3 ‡πÄ‡∏™‡∏µ‡∏¢ + 1 ‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡πÉ‡∏´‡∏ç‡πà"""
        pairs_n_to_1 = []
        
        losing_positions = [p for p in buy_positions + sell_positions if p.pnl < -0.3]
        profitable_positions = [p for p in buy_positions + sell_positions if p.pnl > 1.5]  # ‡∏Å‡∏≥‡πÑ‡∏£‡πÉ‡∏´‡∏ç‡πà > $1.5
        
        # 2 ‡πÄ‡∏™‡∏µ‡∏¢ + 1 ‡∏Å‡∏≥‡πÑ‡∏£‡πÉ‡∏´‡∏ç‡πà - ‡πÉ‡∏ä‡πâ nested loops
        for profit_pos in profitable_positions:
            for i, losing1 in enumerate(losing_positions):
                for losing2 in losing_positions[i+1:]:  # ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≥
                    net_pnl = profit_pos.pnl + losing1.pnl + losing2.pnl
                    
                    if net_pnl > 0.5:
                        priority_score = net_pnl + profit_pos.pnl * 0.7  # bonus ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≥‡πÑ‡∏£‡πÉ‡∏´‡∏ç‡πà
                        
                        pairs_n_to_1.append({
                            'losing_positions': [losing1, losing2],
                            'profitable_positions': [profit_pos],
                            'net_profit': net_pnl,
                            'total_positions': 3,
                            'pair_type': "2:1",
                            'priority_score': priority_score,
                            'position_ids': {profit_pos.position_id, losing1.position_id, losing2.position_id}
                        })
            
            # 3 ‡πÄ‡∏™‡∏µ‡∏¢ + 1 ‡∏Å‡∏≥‡πÑ‡∏£‡πÉ‡∏´‡∏ç‡πà (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏≥‡πÑ‡∏£ > $5)
            if profit_pos.pnl > 5 and len(losing_positions) >= 3:
                for i, losing1 in enumerate(losing_positions[:3]):  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î 3 ‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å
                    for j, losing2 in enumerate(losing_positions[i+1:3]):
                        for losing3 in losing_positions[i+j+2:3]:
                            total_loss = losing1.pnl + losing2.pnl + losing3.pnl
                            if total_loss > -4:  # ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡∏£‡∏ß‡∏°‡πÄ‡∏Å‡∏¥‡∏ô $4
                                net_pnl = profit_pos.pnl + total_loss
                                
                                if net_pnl > 0.8:
                                    priority_score = net_pnl + profit_pos.pnl * 0.8
                                    
                                    pairs_n_to_1.append({
                                        'losing_positions': [losing1, losing2, losing3],
                                        'profitable_positions': [profit_pos],
                                        'net_profit': net_pnl,
                                        'total_positions': 4,
                                        'pair_type': "3:1",
                                        'priority_score': priority_score,
                                        'position_ids': {profit_pos.position_id, losing1.position_id, losing2.position_id, losing3.position_id}
                                    })
        
        return pairs_n_to_1

    def find_complex_pairs(self, buy_positions, sell_positions):
        """‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡πÅ‡∏ö‡∏ö‡∏ú‡∏™‡∏° 2:2, 2:3 (advanced)"""
        pairs_complex = []
        
        losing_positions = [p for p in buy_positions + sell_positions if p.pnl < -0.5]
        profitable_positions = [p for p in buy_positions + sell_positions if p.pnl > 1]
        
        # 2 ‡πÄ‡∏™‡∏µ‡∏¢ + 2 ‡∏Å‡∏≥‡πÑ‡∏£ - ‡πÉ‡∏ä‡πâ nested loops
        if len(losing_positions) >= 2 and len(profitable_positions) >= 2:
            for i, losing1 in enumerate(losing_positions[:3]):  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î 3 ‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å
                for losing2 in losing_positions[i+1:3]:
                    for j, profit1 in enumerate(profitable_positions[:3]):
                        for profit2 in profitable_positions[j+1:3]:
                            net_pnl = losing1.pnl + losing2.pnl + profit1.pnl + profit2.pnl
                            
                            if net_pnl > 0.8:  # threshold ‡∏ï‡πà‡∏≥‡∏•‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö complex
                                priority_score = net_pnl + abs(losing1.pnl + losing2.pnl) * 0.6
                                
                                pairs_complex.append({
                                    'losing_positions': [losing1, losing2],
                                    'profitable_positions': [profit1, profit2],
                                    'net_profit': net_pnl,
                                    'total_positions': 4,
                                    'pair_type': "2:2",
                                    'priority_score': priority_score,
                                    'position_ids': {losing1.position_id, losing2.position_id, profit1.position_id, profit2.position_id}
                                })
        
        return pairs_complex

    def select_non_overlapping_pairs(self, all_pairs):
        """‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô (greedy selection)"""
        selected_pairs = []
        used_position_ids = set()
        
        for pair in all_pairs:
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ position ‡πÉ‡∏î‡πÜ ‡πÉ‡∏ô‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏´‡∏°
            if not pair['position_ids'].intersection(used_position_ids):
                selected_pairs.append(pair)
                used_position_ids.update(pair['position_ids'])
                
                # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏π‡πà‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏•‡∏∞‡πÄ‡∏¢‡∏≠‡∏∞‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)
                if len(selected_pairs) >= 5:  # ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 5 ‡∏Ñ‡∏π‡πà‡∏ï‡πà‡∏≠‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                    break
        
        return selected_pairs
    
    def close_single_profitable_position(self, position):
        """‡∏õ‡∏¥‡∏î position ‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡πÑ‡∏£‡∏î‡∏µ"""
        try:
            success = self.close_entire_position(position)
            if success:
                print(f"   ‚úÖ Closed single position: ${position.pnl:.2f} profit")
                
                # ‡∏ß‡∏≤‡∏á order ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏î‡πÅ‡∏ó‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
                current_price = self.grid_system.get_current_price()
                if position.direction == "BUY":
                    new_price = current_price - (150 * 0.01)  # ‡∏ß‡∏≤‡∏á BUY ‡πÉ‡∏´‡∏°‡πà
                    self.grid_system.place_smart_rebalance_order("BUY", new_price, position.lot_size)
                else:
                    new_price = current_price + (150 * 0.01)  # ‡∏ß‡∏≤‡∏á SELL ‡πÉ‡∏´‡∏°‡πà
                    self.grid_system.place_smart_rebalance_order("SELL", new_price, position.lot_size)
                    
        except Exception as e:
            print(f"‚ùå Close single position error: {e}")

    def analyze_pair_opportunities(self, positions):
        """‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ pair closing ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î"""
        try:
            losing_positions = [p for p in positions if p.pnl < 0]
            profit_positions = [p for p in positions if p.pnl > 0]
            
            print(f"\nüìä === PAIR ANALYSIS ===")
            print(f"üî¥ Losing positions: {len(losing_positions)}")
            for pos in losing_positions[:5]:  # ‡πÅ‡∏™‡∏î‡∏á 5 ‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å
                print(f"   ‚Ä¢ {pos.direction} ${pos.pnl:.2f} @ ${pos.entry_price:.2f}")
                
            print(f"üü¢ Profitable positions: {len(profit_positions)}")
            for pos in profit_positions[:5]:  # ‡πÅ‡∏™‡∏î‡∏á 5 ‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å
                print(f"   ‚Ä¢ {pos.direction} +${pos.pnl:.2f} @ ${pos.entry_price:.2f}")
            
            # ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            best_pairs = []
            for losing_pos in losing_positions[:3]:  # ‡πÄ‡∏ä‡πá‡∏Ñ 3 ‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î
                for profit_pos in profit_positions:
                    net_pnl = losing_pos.pnl + profit_pos.pnl
                    if net_pnl > 0:
                        best_pairs.append({
                            'net_profit': net_pnl,
                            'losing': f"{losing_pos.direction}(${losing_pos.pnl:.2f})",
                            'profit': f"{profit_pos.direction}(+${profit_pos.pnl:.2f})"
                        })
            
            best_pairs.sort(key=lambda x: x['net_profit'], reverse=True)
            
            print(f"üéØ Best potential pairs:")
            for i, pair in enumerate(best_pairs[:3]):
                print(f"   {i+1}. {pair['losing']} + {pair['profit']} = +${pair['net_profit']:.2f}")
                
            print(f"{'='*40}\n")
            
        except Exception as e:
            print(f"‚ùå Pair analysis error: {e}")


    def execute_pair_closes(self, pairs):
        """‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà positions ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ - ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Multi-Position"""
        
        for pair in pairs:
            try:
                # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô SINGLE position ‡∏´‡∏£‡∏∑‡∏≠ Multi-Position
                if pair['pair_type'] == "SINGLE":
                    # ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
                    pos = pair['profitable_positions'][0]
                    success = self.close_entire_position(pos)
                    if success:
                        print(f"   ‚úÖ Single closed: +${pair['net_profit']:.2f}")
                    else:
                        print(f"   ‚ùå Single close failed")
                        
                else:
                    # ‡∏õ‡∏¥‡∏î Multi-Position (1:1, 1:2, 2:1, etc.)
                    all_positions = pair['losing_positions'] + pair['profitable_positions']
                    
                    print(f"üí∞ Closing {pair['pair_type']}: {len(all_positions)} pos = +${pair['net_profit']:.2f}")
                    
                    success_count = 0
                    for pos in all_positions:
                        success = self.close_entire_position(pos)
                        if success:
                            success_count += 1
                            print(f"   ‚úÖ Closed: ${pos.pnl:.2f}")
                            time.sleep(0.2)  # ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà
                        else:
                            print(f"   ‚ùå Failed: ${pos.pnl:.2f}")
                    
                    if success_count == len(all_positions):
                        print(f"   üéâ {pair['pair_type']} completed: +${pair['net_profit']:.2f}")
                        
            except Exception as e:
                print(f"‚ùå Pair close error: {e}")

    def find_hedge_opportunities(self, positions):
        """‡∏´‡∏≤‡πÇ‡∏≠‡∏Å‡∏≤‡∏™ hedge ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö positions ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏°‡∏≤‡∏Å"""
        
        try:
            hedge_opportunities = []
            heavy_losers = [p for p in positions if p.pnl < -10]  # ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô $10
            
            if not heavy_losers:
                return []
            
            # ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡∏≤‡∏° direction
            losing_buys = [p for p in heavy_losers if p.direction == "BUY"]
            losing_sells = [p for p in heavy_losers if p.direction == "SELL"]
            
            # Hedge BUY positions ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
            if losing_buys:
                total_buy_loss = sum(p.pnl for p in losing_buys)
                total_buy_lots = sum(p.lot_size for p in losing_buys)
                
                hedge_opportunities.append({
                    'type': 'SELL_HEDGE',
                    'direction': 'SELL',
                    'lot_size': round(total_buy_lots * 0.6, 3),  # 60% hedge
                    'target_loss': total_buy_loss,
                    'target_positions': losing_buys
                })
            
            # Hedge SELL positions ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
            if losing_sells:
                total_sell_loss = sum(p.pnl for p in losing_sells)
                total_sell_lots = sum(p.lot_size for p in losing_sells)
                
                hedge_opportunities.append({
                    'type': 'BUY_HEDGE',
                    'direction': 'BUY',
                    'lot_size': round(total_sell_lots * 0.6, 3),  # 60% hedge
                    'target_loss': total_sell_loss,
                    'target_positions': losing_sells
                })
            
            return hedge_opportunities
            
        except Exception as e:
            print(f"‚ùå Find hedge opportunities error: {e}")
            return []

    def execute_smart_hedges(self, hedge_opportunities):
        """‡∏ß‡∏≤‡∏á smart hedges"""
        
        for hedge in hedge_opportunities:
            try:
                direction = hedge['direction']
                lot_size = hedge['lot_size']
                target_loss = hedge['target_loss']
                
                print(f"üõ°Ô∏è Placing {direction} hedge: {lot_size} lots for ${target_loss:.2f} loss")
                
                # ‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
                success = self.grid_system.place_hedge_order(direction, lot_size)
                if success:
                    print(f"   ‚úÖ {direction} hedge placed successfully")
                else:
                    print(f"   ‚ùå Failed to place {direction} hedge")
                    
            except Exception as e:
                print(f"‚ùå Execute hedge error: {e}")

    def place_replacement_orders_after_pair_close(self, closed_pos1, closed_pos2):
        """‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà"""
        
        try:
            current_price = self.grid_system.get_current_price()
            
            # ‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ BUY ‡πÅ‡∏•‡∏∞ SELL ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏Å‡∏•‡πâ current price
            buy_price = current_price - (200 * 0.01)   # 200 points ‡∏•‡∏á
            sell_price = current_price + (200 * 0.01)  # 200 points ‡∏Ç‡∏∂‡πâ‡∏ô
            
            avg_lot = (closed_pos1.lot_size + closed_pos2.lot_size) / 2
            
            # ‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡∏ó‡∏î‡πÅ‡∏ó‡∏ô
            self.place_single_replacement_order("BUY", buy_price, avg_lot)
            self.place_single_replacement_order("SELL", sell_price, avg_lot)
            
            print(f"   üîÑ Replacement orders placed: BUY @ ${buy_price:.2f}, SELL @ ${sell_price:.2f}")
            
        except Exception as e:
            print(f"‚ùå Replacement orders error: {e}")

    def place_single_replacement_order(self, direction, price, lot_size):
        """‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ó‡∏î‡πÅ‡∏ó‡∏ô"""
        
        try:
            from ai_gold_grid import GridLevel, PositionStatus
            
            new_level = GridLevel(
                level_id=f"AI_REPLACE_{direction}_{int(time.time())}",
                price=round(price, 2),
                lot_size=round(lot_size, 3),
                direction=direction,
                status=PositionStatus.PENDING,
                entry_time=datetime.now()
            )
            
            order_result = self.grid_system.place_pending_order(new_level)
            if order_result:
                new_level.order_id = order_result
                self.grid_system.grid_levels.append(new_level)
                self.grid_system.pending_orders[order_result] = new_level
                return True
            
        except Exception as e:
            print(f"‚ùå Place replacement error: {e}")
        return False
    
    def handle_buy_heavy_situation(self, buy_positions, sell_positions):
        """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠ BUY positions ‡πÄ‡∏¢‡∏≠‡∏∞‡πÄ‡∏Å‡∏¥‡∏ô"""
        try:
            # 1. ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥
            best_pairs = self.find_best_closing_pairs(buy_positions, sell_positions)
            
            if best_pairs:
                print(f"üí∞ Closing {len(best_pairs)} profitable pairs")
                for pair in best_pairs:
                    self.close_position_pair(pair['buy_pos'], pair['sell_pos'], pair['net_profit'])
                    
            # 2. ‡πÄ‡∏û‡∏¥‡πà‡∏° SELL orders ‡πÉ‡∏Å‡∏•‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            current_price = self.grid_system.get_current_price()
            self.add_sell_orders_for_balance(current_price, min(2, len(buy_positions) - len(sell_positions)))
            
        except Exception as e:
            print(f"‚ùå BUY heavy handling error: {e}")

    def handle_sell_heavy_situation(self, buy_positions, sell_positions):
        """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠ SELL positions ‡πÄ‡∏¢‡∏≠‡∏∞‡πÄ‡∏Å‡∏¥‡∏ô"""  
        try:
            # 1. ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥
            best_pairs = self.find_best_closing_pairs(sell_positions, buy_positions)
            
            if best_pairs:
                print(f"üí∞ Closing {len(best_pairs)} profitable pairs")
                for pair in best_pairs:
                    self.close_position_pair(pair['sell_pos'], pair['buy_pos'], pair['net_profit'])
                    
            # 2. ‡πÄ‡∏û‡∏¥‡πà‡∏° BUY orders ‡πÉ‡∏Å‡∏•‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô  
            current_price = self.grid_system.get_current_price()
            self.add_buy_orders_for_balance(current_price, min(2, len(sell_positions) - len(buy_positions)))
            
        except Exception as e:
            print(f"‚ùå SELL heavy handling error: {e}")

    def find_best_closing_pairs(self, heavy_positions, light_positions):
        """‡∏´‡∏≤‡∏Ñ‡∏π‡πà positions ‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥"""
        try:
            profitable_pairs = []
            
            for heavy_pos in heavy_positions:
                for light_pos in light_positions:
                    net_pnl = heavy_pos.pnl + light_pos.pnl
                    
                    # ‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ > $3 ‡∏ñ‡∏∂‡∏á‡∏à‡∏∞‡∏õ‡∏¥‡∏î
                    if net_pnl > 3:
                        profitable_pairs.append({
                            'heavy_pos': heavy_pos,
                            'light_pos': light_pos,  
                            'buy_pos': heavy_pos if heavy_pos.direction == "BUY" else light_pos,
                            'sell_pos': heavy_pos if heavy_pos.direction == "SELL" else light_pos,
                            'net_profit': net_pnl,
                            'priority': net_pnl + abs(min(heavy_pos.pnl, light_pos.pnl))
                        })
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° priority ‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥
            profitable_pairs.sort(key=lambda x: x['priority'], reverse=True)
            
            selected_pairs = []
            used_positions = set()
            
            for pair in profitable_pairs:
                heavy_id = pair['heavy_pos'].position_id  
                light_id = pair['light_pos'].position_id
                
                if heavy_id not in used_positions and light_id not in used_positions:
                    selected_pairs.append(pair)
                    used_positions.add(heavy_id)
                    used_positions.add(light_id)
                    
                    if len(selected_pairs) >= 1:  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÅ‡∏Ñ‡πà 1 ‡∏Ñ‡∏π‡πà‡∏ï‡πà‡∏≠‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                        break
                        
            return selected_pairs
            
        except Exception as e:
            print(f"‚ùå Find pairs error: {e}")
            return []

    def close_position_pair(self, pos1, pos2, expected_profit):
        """‡∏õ‡∏¥‡∏î positions ‡∏Ñ‡∏π‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô"""
        try:
            print(f"üéØ Closing pair: {pos1.direction} ${pos1.pnl:.2f} + {pos2.direction} ${pos2.pnl:.2f} = +${expected_profit:.2f}")
            
            # ‡∏õ‡∏¥‡∏î position ‡πÅ‡∏£‡∏Å
            success1 = self.close_single_position(pos1)
            if success1:
                time.sleep(0.3)  # ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà
                
                # ‡∏õ‡∏¥‡∏î position ‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏á
                success2 = self.close_single_position(pos2)
                if success2:
                    print(f"   ‚úÖ Pair closed successfully: +${expected_profit:.2f}")
                    return True
                else:
                    print(f"   ‚ö†Ô∏è Second position failed to close")
            else:
                print(f"   ‚ùå First position failed to close")
                
            return False
            
        except Exception as e:
            print(f"‚ùå Close pair error: {e}")
            return False

    def close_single_position(self, position):
        """‡∏õ‡∏¥‡∏î position ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß - ‡πÉ‡∏ä‡πâ MT5 API ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß)"""
        try:
            import MetaTrader5 as mt5
            
            # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: Detailed logging
            print(f"üéØ Attempting to close position: {position.position_id}")
            print(f"   Direction: {position.direction}, PnL: ${position.pnl:.2f}")
            print(f"   Lot Size: {position.lot_size}, Entry: ${position.entry_price:.2f}")
            
            # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ position ‡∏¢‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏´‡∏°
            existing_position = mt5.positions_get(ticket=position.position_id)
            if not existing_position:
                print(f"   ‚ö†Ô∏è Position {position.position_id} not found - already closed?")
                return True  # ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏°‡πâ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß
                
            # Get current symbol info and tick
            symbol_info = mt5.symbol_info(self.grid_system.gold_symbol)
            if not symbol_info:
                print(f"   ‚ùå Cannot get symbol info for {self.grid_system.gold_symbol}")
                return False
                
            tick = mt5.symbol_info_tick(self.grid_system.gold_symbol)
            if not tick:
                print(f"   ‚ùå Cannot get tick data for {self.grid_system.gold_symbol}")
                return False
            
            # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ MT5 API ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
            if position.direction == "BUY":
                trade_type = mt5.ORDER_TYPE_SELL
                price = tick.bid
                print(f"   üìâ Closing BUY with SELL at ${price:.2f}")
            else:
                trade_type = mt5.ORDER_TYPE_BUY  
                price = tick.ask
                print(f"   üìà Closing SELL with BUY at ${price:.2f}")
            
            # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö lot size
            min_volume = symbol_info.volume_min
            volume_step = symbol_info.volume_step
            
            # Validate ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö lot size
            lot_size = position.lot_size
            if lot_size < min_volume:
                lot_size = min_volume
                print(f"   üîß Adjusted lot size: {position.lot_size} ‚Üí {lot_size}")
            
            # Round to volume step
            lot_size = round(lot_size / volume_step) * volume_step
            
            # ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á close request
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": self.grid_system.gold_symbol,
                "volume": lot_size,
                "type": trade_type,
                "position": position.position_id,  # ‡πÉ‡∏ä‡πâ position ticket
                "price": price,
                "deviation": 50,  # ‡πÄ‡∏û‡∏¥‡πà‡∏° deviation
                "magic": self.grid_system.magic_number,
                "comment": "SmartClose_Direct",
                "type_filling": mt5.ORDER_FILLING_IOC  # ‡πÉ‡∏ä‡πâ IOC ‡πÅ‡∏ó‡∏ô
            }
            
            print(f"   üì§ Sending close request: {lot_size} lots @ ${price:.2f}")
            
            # ‚úÖ ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏õ‡∏¥‡∏î
            result = mt5.order_send(request)
            
            if result:
                print(f"   üì® MT5 Response: Code={result.retcode}, Comment='{result.comment}'")
                
                if result.retcode == mt5.TRADE_RETCODE_DONE:
                    print(f"   ‚úÖ Successfully closed position {position.position_id}")
                    
                    # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï position tracking
                    if hasattr(self, 'mark_recently_closed'):
                        self.mark_recently_closed(position.position_id)
                    
                    return True
                
                elif result.retcode == mt5.TRADE_RETCODE_REQUOTE:
                    print(f"   üîÑ Requote received, retrying with market execution...")
                    return self.retry_close_at_market(position)
                    
                elif result.retcode == mt5.TRADE_RETCODE_INVALID_FILL:
                    print(f"   üîÑ Invalid fill mode, trying different modes...")
                    return self.retry_close_different_fill_mode(position)
                    
                else:
                    print(f"   ‚ùå Close failed: {result.retcode} - {result.comment}")
                    return False
            else:
                print(f"   ‚ùå No response from MT5")
                return False
                
        except Exception as e:
            print(f"‚ùå Close single position error: {e}")
            import traceback
            print(f"üîß Traceback: {traceback.format_exc()}")
            return False

    def retry_close_at_market(self, position):
        """‡∏•‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡∏î‡πâ‡∏ß‡∏¢ market execution"""
        try:
            import MetaTrader5 as mt5
            
            tick = mt5.symbol_info_tick(self.grid_system.gold_symbol)
            if not tick:
                return False
                
            if position.direction == "BUY":
                trade_type = mt5.ORDER_TYPE_SELL
                price = tick.bid
            else:
                trade_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
            
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": self.grid_system.gold_symbol,
                "volume": position.lot_size,
                "type": trade_type,
                "position": position.position_id,
                "price": price,
                "deviation": 100,  # ‡πÄ‡∏û‡∏¥‡πà‡∏° deviation ‡∏°‡∏≤‡∏Å
                "magic": self.grid_system.magic_number,
                "comment": "SmartClose_Market",
                "type_filling": mt5.ORDER_FILLING_IOC
            }
            
            result = mt5.order_send(request)
            
            if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                print(f"   ‚úÖ Market close successful")
                return True
            else:
                print(f"   ‚ùå Market close failed: {result.retcode if result else 'No response'}")
                return False
                
        except Exception as e:
            print(f"‚ùå Market close retry error: {e}")
            return False

    def retry_close_different_fill_mode(self, position):
        """‡∏•‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡∏î‡πâ‡∏ß‡∏¢ fill mode ‡∏ï‡πà‡∏≤‡∏á‡πÜ"""
        try:
            import MetaTrader5 as mt5
            
            fill_modes = [
                (mt5.ORDER_FILLING_RETURN, "RETURN"),
                (mt5.ORDER_FILLING_IOC, "IOC"),
                (mt5.ORDER_FILLING_FOK, "FOK")
            ]
            
            tick = mt5.symbol_info_tick(self.grid_system.gold_symbol)
            if not tick:
                return False
                
            if position.direction == "BUY":
                trade_type = mt5.ORDER_TYPE_SELL
                price = tick.bid
            else:
                trade_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
            
            for fill_mode, mode_name in fill_modes:
                print(f"   üîÑ Trying {mode_name} fill mode...")
                
                request = {
                    "action": mt5.TRADE_ACTION_DEAL,
                    "symbol": self.grid_system.gold_symbol,
                    "volume": position.lot_size,
                    "type": trade_type,
                    "position": position.position_id,
                    "price": price,
                    "deviation": 50,
                    "magic": self.grid_system.magic_number,
                    "comment": f"SmartClose_{mode_name}",
                    "type_filling": fill_mode
                }
                
                result = mt5.order_send(request)
                
                if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                    print(f"   ‚úÖ {mode_name} fill mode successful")
                    return True
                elif result:
                    print(f"   ‚ùå {mode_name} failed: {result.retcode}")
            
            print(f"   ‚ùå All fill modes failed")
            return False
            
        except Exception as e:
            print(f"‚ùå Fill mode retry error: {e}")
            return False
    

    def check_and_fill_gaps(self, current_price):
        """‡πÄ‡∏ä‡πá‡∏Ñ‡πÅ‡∏•‡∏∞‡πÄ‡∏ï‡∏¥‡∏°‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤ - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß"""
        try:
            all_orders = list(self.grid_system.pending_orders.values())
            if not all_orders:
                return
                
            buy_orders = [o for o in all_orders if o.direction == "BUY"]
            sell_orders = [o for o in all_orders if o.direction == "SELL"]
            
            # ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á BUY ‡∏î‡πâ‡∏≤‡∏ô (‡∏•‡∏î‡∏à‡∏≤‡∏Å 300 ‚Üí 150 points)
            if buy_orders:
                nearest_buy = max(buy_orders, key=lambda x: x.price)
                buy_gap = (current_price - nearest_buy.price) / 0.01  # points
                
                if buy_gap > 150:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 300 ‚Üí 150 ‡∏à‡∏∏‡∏î (‡πÑ‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô 50%)
                    fill_price = current_price - (100 * 0.01)  # ‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà 100 ‡∏à‡∏∏‡∏î (‡∏à‡∏≤‡∏Å 150)
                    # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ parameter order ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (direction ‡∏Å‡πà‡∏≠‡∏ô, price ‡∏´‡∏•‡∏±‡∏á)
                    if not self.grid_system.has_nearby_order("BUY", fill_price, 50):
                        self.grid_system.place_smart_rebalance_order("BUY", fill_price, self.grid_system.base_lot)
                        print(f"üîß Fill BUY gap: @ ${fill_price:.2f} (was {buy_gap:.0f} points)")
            else:
                # ‡πÑ‡∏°‡πà‡∏°‡∏µ BUY orders ‡πÄ‡∏•‡∏¢ - ‡∏ß‡∏≤‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ!
                fill_price = current_price - (80 * 0.01)  # ‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà 80 ‡∏à‡∏∏‡∏î
                if not self.grid_system.has_nearby_order("BUY", fill_price, 50):
                    self.grid_system.place_smart_rebalance_order("BUY", fill_price, self.grid_system.base_lot)
                    print(f"üö® Emergency BUY: @ ${fill_price:.2f}")
            
            # ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á SELL ‡∏î‡πâ‡∏≤‡∏ô (‡∏•‡∏î‡∏à‡∏≤‡∏Å 300 ‚Üí 150 points)
            if sell_orders:
                nearest_sell = min(sell_orders, key=lambda x: x.price)
                sell_gap = (nearest_sell.price - current_price) / 0.01  # points
                
                if sell_gap > 150:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 300 ‚Üí 150 ‡∏à‡∏∏‡∏î (‡πÑ‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô 50%)
                    fill_price = current_price + (100 * 0.01)  # ‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà 100 ‡∏à‡∏∏‡∏î (‡∏à‡∏≤‡∏Å 150)
                    # ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ parameter order ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (direction ‡∏Å‡πà‡∏≠‡∏ô, price ‡∏´‡∏•‡∏±‡∏á)
                    if not self.grid_system.has_nearby_order("SELL", fill_price, 50):
                        self.grid_system.place_smart_rebalance_order("SELL", fill_price, self.grid_system.base_lot)
                        print(f"üîß Fill SELL gap: @ ${fill_price:.2f} (was {sell_gap:.0f} points)")
            else:
                # ‡πÑ‡∏°‡πà‡∏°‡∏µ SELL orders ‡πÄ‡∏•‡∏¢ - ‡∏ß‡∏≤‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ!
                fill_price = current_price + (80 * 0.01)  # ‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà 80 ‡∏à‡∏∏‡∏î
                if not self.grid_system.has_nearby_order("SELL", fill_price, 50):
                    self.grid_system.place_smart_rebalance_order("SELL", fill_price, self.grid_system.base_lot)
                    print(f"üö® Emergency SELL: @ ${fill_price:.2f}")
                        
        except Exception as e:
            print(f"‚ùå Gap filling error: {e}")


    def place_market_rebalance_order(self, direction: str) -> bool:
        """‡πÄ‡∏û‡∏¥‡πà‡∏° method ‡πÉ‡∏´‡∏°‡πà - ‡∏ß‡∏≤‡∏á Market Order ‡πÄ‡∏û‡∏∑‡πà‡∏≠ Balance"""
        try:
            # Get current tick
            tick = mt5.symbol_info_tick(self.grid_system.gold_symbol)
            if not tick:
                print(f"‚ùå Cannot get tick for market rebalance")
                return False
                
            # ‡πÉ‡∏ä‡πâ lot size ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
            lot_size = self.grid_system.base_lot
            
            # Determine price and order type
            if direction == "BUY":
                order_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
            else:
                order_type = mt5.ORDER_TYPE_SELL
                price = tick.bid
                
            # Market order request
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": self.grid_system.gold_symbol,
                "volume": lot_size,
                "type": order_type,
                "price": price,
                "deviation": 30,  # Allow slippage for market order
                "magic": self.grid_system.magic_number,
                "comment": f"REBALANCE_{direction}",
                "type_filling": self.grid_system.order_filling_mode
            }
            
            print(f"   üéØ Market {direction}: {lot_size:.3f} @ ${price:.2f}")
            
            result = mt5.order_send(request)
            
            if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                print(f"   ‚úÖ Market rebalance: {direction} executed!")
                
                # Track ‡πÉ‡∏ô grid system
                from ai_gold_grid import GridLevel, PositionStatus
                
                market_level = GridLevel(
                    level_id=f"REBALANCE_{direction}_{int(time.time())}",
                    price=price,
                    lot_size=lot_size,
                    direction=direction,
                    status=PositionStatus.ACTIVE,
                    position_id=result.order,
                    entry_time=datetime.now()
                )
                
                self.grid_system.grid_levels.append(market_level)
                self.grid_system.active_positions[result.order] = market_level
                
                return True
            else:
                print(f"   ‚ùå Market rebalance failed: {result.comment if result else 'No response'}")
                return False
                
        except Exception as e:
            print(f"‚ùå Market rebalance order error: {e}")
            return False

    def log_portfolio_status(self, portfolio_analysis: Dict):
        """Log current portfolio status"""
        
        try:
            total_pnl = portfolio_analysis.get('total_pnl', 0)
            total_positions = portfolio_analysis.get('total_positions', 0)
            hedge_positions = portfolio_analysis.get('hedge_positions', 0)
            risk_pct = portfolio_analysis.get('risk_percentage', 0)
            
            status_emoji = "üìà" if total_pnl >= 0 else "üìâ"
            risk_emoji = "üü¢" if risk_pct < 10 else "üü°" if risk_pct < 20 else "üî¥"
            
        except Exception as e:
            print(f"‚ùå Portfolio logging error: {e}")
            
    def get_profit_management_status(self) -> Dict:
        """Get current profit management status for GUI"""
        
        try:
            portfolio_analysis = self.analyze_portfolio_positions()
            
            return {
                'strategy': self.default_strategy.value,
                'total_positions': portfolio_analysis.get('total_positions', 0),
                'hedge_positions': portfolio_analysis.get('hedge_positions', 0),
                'total_pnl': portfolio_analysis.get('total_pnl', 0),
                'risk_percentage': portfolio_analysis.get('risk_percentage', 0),
                'trailing_stops_active': sum(1 for pos in portfolio_analysis.get('grid_positions', []) 
                                           if hasattr(pos, 'trailing_stop_price') and pos.trailing_stop_price is not None),
                'last_update': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {'error': str(e)}

    def check_and_run_recovery(self, portfolio_analysis: Dict):
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ Recovery System"""
        try:
            total_pnl = portfolio_analysis.get('total_pnl', 0)
            
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç trigger
            should_trigger = (
                total_pnl <= self.recovery_trigger_loss and  # ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î
                not self.recovery_active and                 # ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà active
                len(portfolio_analysis.get('grid_positions', [])) > 0  # ‡∏°‡∏µ positions
            )
            
            if should_trigger:
                if self.recovery_auto_mode:
                    self.start_portfolio_recovery(portfolio_analysis)
                else:
                    print(f"üíä Recovery trigger: PnL ${total_pnl:.2f} < ${self.recovery_trigger_loss}")
                    print(f"   Use manual recovery or enable auto_mode")
            
            # ‡∏ñ‡πâ‡∏≤ recovery active ‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ú‡∏•
            elif self.recovery_active:
                self.monitor_recovery_progress(portfolio_analysis)
                
        except Exception as e:
            print(f"‚ùå Recovery check error: {e}")

    def start_portfolio_recovery(self, portfolio_analysis: Dict):
        """‡πÄ‡∏£‡∏¥‡πà‡∏° Portfolio Recovery Process"""
        try:
            print(f"üíä === PORTFOLIO RECOVERY STARTED ===")
            
            self.recovery_active = True
            self.recovery_start_time = datetime.now()
            self.recovery_initial_pnl = portfolio_analysis.get('total_pnl', 0)
            
            print(f"   Initial PnL: ${self.recovery_initial_pnl:.2f}")
            print(f"   Target: Break-even or positive")
            
            # ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ recovery
            recovery_plan = self.analyze_recovery_opportunities(portfolio_analysis)
            
            if recovery_plan['viable']:
                self.execute_recovery_plan(recovery_plan)
            else:
                print(f"   ‚ö†Ô∏è No viable recovery options found")
                self.recovery_active = False
                
        except Exception as e:
            print(f"‚ùå Recovery start error: {e}")
            self.recovery_active = False

    def analyze_recovery_opportunities(self, portfolio_analysis: Dict) -> Dict:
        """‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô portfolio"""
        try:
            positions = portfolio_analysis.get('grid_positions', [])
            
            # ‡πÅ‡∏¢‡∏Å positions ‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
            losing_positions = [p for p in positions if p.pnl < -1]  # ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô > $1
            profitable_positions = [p for p in positions if p.pnl > 1]  # ‡∏Å‡∏≥‡πÑ‡∏£ > $1
            neutral_positions = [p for p in positions if -1 <= p.pnl <= 1]  # ‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á
            
            total_loss = sum(p.pnl for p in losing_positions)
            total_profit = sum(p.pnl for p in profitable_positions)
            net_pnl = total_loss + total_profit
            
            print(f"   üìä Recovery Analysis:")
            print(f"      Losing: {len(losing_positions)} positions (${total_loss:.2f})")
            print(f"      Profitable: {len(profitable_positions)} positions (+${total_profit:.2f})")
            print(f"      Neutral: {len(neutral_positions)} positions")
            print(f"      Net PnL: ${net_pnl:.2f}")
            
            # ‡∏´‡∏≤‡∏Ñ‡∏π‡πà positions ‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏¥‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£
            optimal_pairs = self.find_optimal_pairs(losing_positions, profitable_positions)
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì hedge opportunities
            hedge_opportunities = self.calculate_hedge_recovery(losing_positions)
            
            recovery_plan = {
                'viable': len(optimal_pairs) > 0 or len(hedge_opportunities) > 0,
                'optimal_pairs': optimal_pairs,
                'hedge_opportunities': hedge_opportunities,
                'total_recovery_potential': sum(pair['net_profit'] for pair in optimal_pairs),
                'losing_positions': losing_positions,
                'profitable_positions': profitable_positions
            }
            
            print(f"   üéØ Recovery Plan:")
            print(f"      Optimal pairs: {len(optimal_pairs)}")
            print(f"      Recovery potential: ${recovery_plan['total_recovery_potential']:.2f}")
            print(f"      Viable: {recovery_plan['viable']}")
            
            return recovery_plan
            
        except Exception as e:
            print(f"‚ùå Recovery analysis error: {e}")
            return {'viable': False}

    def find_optimal_pairs(self, losing_positions: List, profitable_positions: List) -> List[Dict]:
        """‡∏´‡∏≤‡∏Ñ‡∏π‡πà positions ‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥"""
        try:
            optimal_pairs = []
            
            # ‡∏™‡∏≥‡πÄ‡∏ô‡∏≤ list ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
            remaining_losing = losing_positions.copy()
            remaining_profitable = profitable_positions.copy()
            
            for losing_pos in remaining_losing:
                for profitable_pos in remaining_profitable:
                    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ
                    net_profit = losing_pos.pnl + profitable_pos.pnl
                    
                    # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ > $2
                    if net_profit > 2:
                        pair_info = {
                            'losing_position': losing_pos,
                            'profitable_position': profitable_pos,
                            'losing_pnl': losing_pos.pnl,
                            'profitable_pnl': profitable_pos.pnl,
                            'net_profit': net_profit,
                            'priority_score': net_profit + abs(losing_pos.pnl)  # ‡∏¢‡∏¥‡πà‡∏á‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏°‡∏≤‡∏Å priority ‡∏™‡∏π‡∏á
                        }
                        optimal_pairs.append(pair_info)
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° priority score (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô)
            optimal_pairs.sort(key=lambda x: x['priority_score'], reverse=True)
            
            # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô (greedy selection)
            selected_pairs = []
            used_positions = set()
            
            for pair in optimal_pairs:
                losing_id = pair['losing_position'].position_id
                profitable_id = pair['profitable_position'].position_id
                
                if losing_id not in used_positions and profitable_id not in used_positions:
                    selected_pairs.append(pair)
                    used_positions.add(losing_id)
                    used_positions.add(profitable_id)
            
            print(f"      Found {len(selected_pairs)} optimal pairs:")
            for i, pair in enumerate(selected_pairs[:3]):  # ‡πÅ‡∏™‡∏î‡∏á 3 ‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö‡πÅ‡∏£‡∏Å
                print(f"         {i+1}. Loss ${pair['losing_pnl']:.2f} + Profit ${pair['profitable_pnl']:.2f} = Net +${pair['net_profit']:.2f}")
            
            return selected_pairs
            
        except Exception as e:
            print(f"‚ùå Pair finding error: {e}")
            return []

    def calculate_hedge_recovery(self, losing_positions: List) -> List[Dict]:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡πÉ‡∏ä‡πâ hedge ‡πÄ‡∏û‡∏∑‡πà‡∏≠ recovery"""
        try:
            hedge_opportunities = []
            
            # ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡∏≤‡∏° direction
            losing_buys = [p for p in losing_positions if p.direction == "BUY"]
            losing_sells = [p for p in losing_positions if p.direction == "SELL"]
            
            current_price = self.grid_system.get_current_price()
            
            # Hedge ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BUY positions ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
            if losing_buys:
                total_buy_loss = sum(p.pnl for p in losing_buys)
                total_buy_lots = sum(p.lot_size for p in losing_buys)
                
                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì SELL hedge ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
                hedge_lot_size = total_buy_lots * 0.8  # 80% hedge
                hedge_price = current_price + (50 * 0.01)  # +50 points
                
                hedge_opportunity = {
                    'type': 'SELL_HEDGE',
                    'target_positions': losing_buys,
                    'hedge_direction': 'SELL',
                    'hedge_lot_size': hedge_lot_size,
                    'hedge_price': hedge_price,
                    'target_loss': total_buy_loss,
                    'estimated_recovery': abs(total_buy_loss) * 0.7  # ‡∏Ñ‡∏≤‡∏î‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏Ñ‡∏∑‡∏ô 70%
                }
                hedge_opportunities.append(hedge_opportunity)
            
            # Hedge ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö SELL positions ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
            if losing_sells:
                total_sell_loss = sum(p.pnl for p in losing_sells)
                total_sell_lots = sum(p.lot_size for p in losing_sells)
                
                hedge_lot_size = total_sell_lots * 0.8
                hedge_price = current_price - (50 * 0.01)  # -50 points
                
                hedge_opportunity = {
                    'type': 'BUY_HEDGE',
                    'target_positions': losing_sells,
                    'hedge_direction': 'BUY',
                    'hedge_lot_size': hedge_lot_size,
                    'hedge_price': hedge_price,
                    'target_loss': total_sell_loss,
                    'estimated_recovery': abs(total_sell_loss) * 0.7
                }
                hedge_opportunities.append(hedge_opportunity)
            
            if hedge_opportunities:
                print(f"      Found {len(hedge_opportunities)} hedge opportunities:")
                for opp in hedge_opportunities:
                    print(f"         {opp['type']}: {opp['hedge_lot_size']:.3f} lots @ ${opp['hedge_price']:.2f}")
                    print(f"            Target recovery: ${opp['estimated_recovery']:.2f}")
            
            return hedge_opportunities
            
        except Exception as e:
            print(f"‚ùå Hedge calculation error: {e}")
            return []

    def execute_recovery_plan(self, recovery_plan: Dict):
        """‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≤‡∏° recovery plan"""
        try:
            executed_actions = 0
            
            # 1. ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£ optimal pairs ‡∏Å‡πà‡∏≠‡∏ô (‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏ï‡πà‡∏≥)
            for pair in recovery_plan['optimal_pairs'][:2]:  # ‡∏ó‡∏≥ 2 ‡∏Ñ‡∏π‡πà‡πÅ‡∏£‡∏Å‡∏Å‡πà‡∏≠‡∏ô
                success = self.execute_pair_close(pair)
                if success:
                    executed_actions += 1
                    print(f"   ‚úÖ Executed pair close: Net +${pair['net_profit']:.2f}")
                else:
                    print(f"   ‚ùå Failed to close pair")
            
            # 2. ‡∏ñ‡πâ‡∏≤ pairs ‡πÑ‡∏°‡πà‡∏û‡∏≠ ‡πÉ‡∏ä‡πâ hedge strategy
            if executed_actions == 0 and recovery_plan['hedge_opportunities']:
                hedge_opp = recovery_plan['hedge_opportunities'][0]  # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å
                success = self.execute_hedge_recovery(hedge_opp)
                if success:
                    executed_actions += 1
                    print(f"   ‚úÖ Executed hedge recovery: {hedge_opp['type']}")
            
            if executed_actions > 0:
                print(f"   üéØ Recovery actions executed: {executed_actions}")
            else:
                print(f"   ‚ö†Ô∏è No recovery actions could be executed")
                self.recovery_active = False
                
        except Exception as e:
            print(f"‚ùå Recovery execution error: {e}")
            self.recovery_active = False

    def execute_pair_close(self, pair: Dict) -> bool:
        """‡∏õ‡∏¥‡∏î position ‡∏Ñ‡∏π‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô"""
        try:
            losing_pos = pair['losing_position']
            profitable_pos = pair['profitable_position']
            
            # ‡∏õ‡∏¥‡∏î position ‡πÅ‡∏£‡∏Å
            success1 = self.close_single_position(losing_pos)
            if not success1:
                return False
            
            # ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà
            time.sleep(0.5)
            
            # ‡∏õ‡∏¥‡∏î position ‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏á
            success2 = self.close_single_position(profitable_pos)
            if not success2:
                print(f"   ‚ö†Ô∏è Warning: First position closed but second failed")
                return False
            
            print(f"   üí∞ Pair closed: ${losing_pos.pnl:.2f} + ${profitable_pos.pnl:.2f} = +${pair['net_profit']:.2f}")
            return True
            
        except Exception as e:
            print(f"‚ùå Pair close error: {e}")
            return False

    def close_single_position(self, position) -> bool:
        """‡∏õ‡∏¥‡∏î position ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (‡πÉ‡∏ä‡πâ function ‡πÄ‡∏î‡∏¥‡∏°)"""
        try:
            # ‡πÉ‡∏ä‡πâ method ‡πÄ‡∏î‡∏¥‡∏°‡∏à‡∏≤‡∏Å smart profit manager
            return self.execute_smart_close(
                position, 
                CloseReason.PORTFOLIO_RISK,  # ‡πÉ‡∏ä‡πâ reason ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
                {'close_percentage': 100}
            )
        except Exception as e:
            print(f"‚ùå Single position close error: {e}")
            return False

    def execute_hedge_recovery(self, hedge_opp: Dict) -> bool:
        """‡∏ß‡∏≤‡∏á hedge order ‡πÄ‡∏û‡∏∑‡πà‡∏≠ recovery"""
        try:
            # ‡πÉ‡∏ä‡πâ method ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô grid system
            success = self.grid_system.place_hedge_order(
                hedge_opp['hedge_direction'],
                hedge_opp['hedge_lot_size']
            )
            
            if success:
                print(f"   üõ°Ô∏è Hedge placed: {hedge_opp['hedge_direction']} {hedge_opp['hedge_lot_size']:.3f} lots")
                return True
            else:
                print(f"   ‚ùå Failed to place hedge")
                return False
                
        except Exception as e:
            print(f"‚ùå Hedge execution error: {e}")
            return False

    def monitor_recovery_progress(self, portfolio_analysis: Dict):
        """‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° progress ‡∏Ç‡∏≠‡∏á recovery"""
        try:
            current_pnl = portfolio_analysis.get('total_pnl', 0)
            recovery_pnl = current_pnl - self.recovery_initial_pnl
            
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ recovery ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
            if current_pnl >= -5:  # ‡πÄ‡∏Å‡∏∑‡∏≠‡∏ö break-even ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≥‡πÑ‡∏£
                print(f"üíä === PORTFOLIO RECOVERY SUCCESSFUL ===")
                print(f"   Initial PnL: ${self.recovery_initial_pnl:.2f}")
                print(f"   Current PnL: ${current_pnl:.2f}")
                print(f"   Recovery Gain: +${recovery_pnl:.2f}")
                
                self.recovery_active = False
                self.recovery_start_time = None
                
            # ‡πÄ‡∏ä‡πá‡∏Ñ timeout (30 ‡∏ô‡∏≤‡∏ó‡∏µ)
            elif self.recovery_start_time:
                elapsed = (datetime.now() - self.recovery_start_time).total_seconds() / 60
                if elapsed > 30:
                    print(f"üíä Recovery timeout after {elapsed:.1f} minutes")
                    print(f"   Recovery gain: +${recovery_pnl:.2f}")
                    self.recovery_active = False
                    
            # ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ
            elif self.recovery_start_time:
                elapsed = (datetime.now() - self.recovery_start_time).total_seconds() / 60
                if int(elapsed) % 5 == 0:  # ‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ
                    print(f"üíä Recovery progress: {elapsed:.1f}min, PnL: ${current_pnl:.2f}, Gain: +${recovery_pnl:.2f}")
                    
        except Exception as e:
            print(f"‚ùå Recovery monitoring error: {e}")

    def manual_trigger_recovery(self):
        """Manual trigger ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö GUI"""
        try:
            if self.recovery_active:
                print(f"üíä Recovery already active")
                return False
                
            portfolio_analysis = self.analyze_portfolio_positions()
            if 'error' in portfolio_analysis:
                print(f"üíä Cannot analyze portfolio for recovery")
                return False
                
            self.start_portfolio_recovery(portfolio_analysis)
            return True
            
        except Exception as e:
            print(f"‚ùå Manual recovery trigger error: {e}")
            return False

    def get_recovery_status(self) -> Dict:
        """‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ recovery ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö GUI"""
        try:
            status = {
                'enabled': self.recovery_enabled,
                'active': self.recovery_active,
                'trigger_loss': self.recovery_trigger_loss,
                'auto_mode': self.recovery_auto_mode
            }
            
            if self.recovery_active and self.recovery_start_time:
                elapsed = (datetime.now() - self.recovery_start_time).total_seconds() / 60
                status.update({
                    'start_time': self.recovery_start_time.isoformat(),
                    'elapsed_minutes': round(elapsed, 1),
                    'initial_pnl': self.recovery_initial_pnl
                })
                
            return status
            
        except Exception as e:
            return {'error': str(e)}

    def run_portfolio_cleanup(self) -> Dict:
        """üßπ Smart Portfolio Cleanup - ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î Portfolio ‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞"""
        try:
            print("üßπ Starting Smart Portfolio Cleanup...")
            
            # 1. ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå portfolio ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            portfolio = self.analyze_portfolio_positions()
            if 'error' in portfolio or not portfolio.get('grid_positions'):
                return {'success': False, 'error': 'No positions to cleanup'}
            
            positions = portfolio['grid_positions']
            initial_count = len(positions)
            initial_margin = self.calculate_total_margin_used(positions)
            
            print(f"üìä Initial Portfolio: {initial_count} positions, ${initial_margin:.2f} margin")
            
            # 2. ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô Portfolio Health
            health_data = self.get_portfolio_health_score(positions)
            print(f"üè• Portfolio Health: {health_data['score']:.0f}/100 ({health_data['status']})")
            
            cleanup_actions = []
            total_closed = 0
            total_margin_freed = 0
            
            # 3. Phase 1: ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ú‡∏¥‡∏î‡∏Ç‡πâ‡∏≤‡∏á‡∏ï‡∏•‡∏≤‡∏î (Priority ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î)
            wrong_side_pairs = self.find_wrong_side_pairs(
                [p for p in positions if p.direction == "BUY"],
                [p for p in positions if p.direction == "SELL"],
                self.grid_system.get_current_price()
            )
            
            if wrong_side_pairs:
                print(f"üö® Phase 1: Closing {len(wrong_side_pairs)} wrong-side pairs...")
                for pair in wrong_side_pairs[:3]:  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 3 ‡∏Ñ‡∏π‡πà‡∏ï‡πà‡∏≠‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                    if self.execute_pair_close(pair):
                        cleanup_actions.append(f"Closed wrong-side pair: +${pair['net_profit']:.2f}")
                        total_closed += pair['total_positions']
                        total_margin_freed += self.estimate_margin_freed(pair)
                        time.sleep(0.5)  # ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πâ‡∏ô
            
            # 4. Phase 2: ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡∏•‡∏î margin load
            margin_efficient_pairs = self.find_margin_efficient_pairs(
                [p for p in positions if p.direction == "BUY" and p.position_id not in self.get_closed_position_ids()],
                [p for p in positions if p.direction == "SELL" and p.position_id not in self.get_closed_position_ids()]
            )
            
            if margin_efficient_pairs:
                print(f"üí™ Phase 2: Closing {len(margin_efficient_pairs)} margin-efficient pairs...")
                for pair in margin_efficient_pairs[:2]:  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î 2 ‡∏Ñ‡∏π‡πà
                    if self.execute_pair_close(pair):
                        cleanup_actions.append(f"Closed margin-efficient pair: +${pair['net_profit']:.2f}")
                        total_closed += pair['total_positions']
                        total_margin_freed += self.estimate_margin_freed(pair)
                        time.sleep(0.5)
            
            # 5. Phase 3: ‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏• BUY:SELL (‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
            remaining_positions = self.get_remaining_positions(positions)
            balance_pairs = self.find_balance_correction_pairs(
                [p for p in remaining_positions if p.direction == "BUY"],
                [p for p in remaining_positions if p.direction == "SELL"]
            )
            
            if balance_pairs:
                print(f"‚öñÔ∏è Phase 3: Balancing {len(balance_pairs)} position pairs...")
                for pair in balance_pairs[:1]:  # ‡∏à‡∏≥‡∏Å‡∏±‡∏î 1 ‡∏Ñ‡∏π‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                    if self.execute_pair_close(pair):
                        cleanup_actions.append(f"Balanced portfolio: +${pair['net_profit']:.2f}")
                        total_closed += pair['total_positions']
                        total_margin_freed += self.estimate_margin_freed(pair)
                        time.sleep(0.5)
            
            # 6. Phase 4: ‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ (‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
            self.reposition_critical_orders()
            
            # 7. ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£ cleanup
            final_positions = self.get_remaining_positions(positions)
            final_health = self.get_portfolio_health_score(final_positions)
            
            cleanup_summary = {
                'success': True,
                'positions_closed': total_closed,
                'margin_freed': total_margin_freed,
                'health_improvement': final_health['score'] - health_data['score'],
                'initial_health': health_data['score'],
                'final_health': final_health['score'],
                'actions_taken': cleanup_actions,
                'final_position_count': len(final_positions)
            }
            
            print(f"‚úÖ Cleanup Complete:")
            print(f"   ‚Ä¢ Positions closed: {total_closed}")
            print(f"   ‚Ä¢ Margin freed: ${total_margin_freed:.2f}")
            print(f"   ‚Ä¢ Health improved: {cleanup_summary['health_improvement']:.1f} points")
            print(f"   ‚Ä¢ Final health: {final_health['score']:.0f}/100")
            
            return cleanup_summary
            
        except Exception as e:
            print(f"‚ùå Portfolio cleanup error: {e}")
            return {'success': False, 'error': str(e)}
    
    def execute_pair_close(self, pair) -> bool:
        """‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà positions ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢"""
        try:
            success_count = 0
            
            # ‡∏õ‡∏¥‡∏î losing positions ‡∏Å‡πà‡∏≠‡∏ô
            for pos in pair.get('losing_positions', []):
                if self.close_position_safely(pos):
                    success_count += 1
                    
            # ‡∏õ‡∏¥‡∏î profitable positions
            for pos in pair.get('profitable_positions', []):
                if self.close_position_safely(pos):
                    success_count += 1
            
            # ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡∏£‡∏∂‡πà‡∏á
            return success_count >= (pair['total_positions'] * 0.6)
            
        except Exception as e:
            print(f"‚ùå Pair close error: {e}")
            return False
    
    def close_position_safely(self, position) -> bool:
        """‡∏õ‡∏¥‡∏î position ‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ ‡∏û‡∏£‡πâ‡∏≠‡∏° retry"""
        try:
            # ‡∏•‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡∏î‡πâ‡∏ß‡∏¢ fill mode ‡∏ï‡πà‡∏≤‡∏á‡πÜ
            fill_modes = [
                ("IOC", mt5.ORDER_FILLING_IOC),
                ("FOK", mt5.ORDER_FILLING_FOK), 
                ("Return", mt5.ORDER_FILLING_RETURN)
            ]
            
            tick = mt5.symbol_info_tick(self.grid_system.gold_symbol)
            if not tick:
                return False
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î
            if position.direction == "BUY":
                trade_type = mt5.ORDER_TYPE_SELL
                price = tick.bid
            else:
                trade_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
            
            # ‡∏•‡∏≠‡∏á fill mode ‡∏ï‡πà‡∏≤‡∏á‡πÜ
            for mode_name, fill_mode in fill_modes:
                request = {
                    "action": mt5.TRADE_ACTION_DEAL,
                    "symbol": self.grid_system.gold_symbol,
                    "volume": position.lot_size,
                    "type": trade_type,
                    "position": position.position_id,
                    "price": price,
                    "deviation": 30,
                    "magic": self.grid_system.magic_number,
                    "comment": f"SmartCleanup_{mode_name}",
                    "type_filling": fill_mode
                }
                
                result = mt5.order_send(request)
                
                if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                    print(f"   ‚úÖ Closed position {position.position_id} ({mode_name})")
                    return True
                elif result:
                    print(f"   ‚ùå {mode_name} failed: {result.retcode}")
            
            return False
            
        except Exception as e:
            print(f"‚ùå Safe close error: {e}")
            return False
    
    def estimate_margin_freed(self, pair) -> float:
        """‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô margin ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏Ñ‡∏∑‡∏ô‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏Ñ‡∏π‡πà"""
        try:
            total_lots = 0
            for pos_list in [pair.get('losing_positions', []), pair.get('profitable_positions', [])]:
                for pos in pos_list:
                    total_lots += pos.lot_size
            
            # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏Å‡∏≤‡∏£ margin per lot (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥)
            margin_per_lot = 1000  # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì $1000 per lot
            return total_lots * margin_per_lot
            
        except:
            return 0
    
    def get_closed_position_ids(self) -> Set[int]:
        """‡∏î‡∏∂‡∏á ID ‡∏Ç‡∏≠‡∏á positions ‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ cleanup ‡∏ô‡∏µ‡πâ"""
        if not hasattr(self, '_cleanup_closed_ids'):
            self._cleanup_closed_ids = set()
        return self._cleanup_closed_ids
    
    def get_remaining_positions(self, original_positions):
        """‡∏î‡∏∂‡∏á positions ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£ cleanup"""
        try:
            # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó portfolio ‡πÉ‡∏´‡∏°‡πà
            portfolio = self.analyze_portfolio_positions()
            return portfolio.get('grid_positions', [])
        except:
            # fallback: ‡∏Å‡∏£‡∏≠‡∏á positions ‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
            closed_ids = self.get_closed_position_ids()
            return [p for p in original_positions if p.position_id not in closed_ids]
    
    def reposition_critical_orders(self):
        """‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤"""
        try:
            current_price = self.grid_system.get_current_price()
            
            # ‡∏´‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏Å‡∏•‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ‡πÑ‡∏°‡πâ
            gaps = self.find_critical_gaps_near_market(current_price)
            
            if gaps['buy_gaps']:
                for gap in gaps['buy_gaps'][:2]:  # ‡∏ß‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 2 ‡πÑ‡∏°‡πâ
                    if gap['gap_size'] > 200:  # ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏´‡∏ç‡πà‡∏Å‡∏ß‡πà‡∏≤ 200 points
                        self.grid_system.place_smart_rebalance_order("BUY", gap['price'], self.grid_system.base_lot)
                        print(f"   üîß Repositioned BUY @ ${gap['price']:.2f}")
            
            if gaps['sell_gaps']:
                for gap in gaps['sell_gaps'][:2]:  # ‡∏ß‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 2 ‡πÑ‡∏°‡πâ
                    if gap['gap_size'] > 200:  # ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏´‡∏ç‡πà‡∏Å‡∏ß‡πà‡∏≤ 200 points
                        self.grid_system.place_smart_rebalance_order("SELL", gap['price'], self.grid_system.base_lot)
                        print(f"   üîß Repositioned SELL @ ${gap['price']:.2f}")
                        
        except Exception as e:
            print(f"‚ùå Reposition error: {e}")
    
    
    def calculate_total_margin_used(self, positions) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì margin ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
        try:
            total_margin = 0
            for pos in positions:
                # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏Å‡∏≤‡∏£ margin ‡∏ï‡πà‡∏≠ lot ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥
                margin_per_lot = 1000
                total_margin += pos.lot_size * margin_per_lot
            return total_margin
        except:
            return 0

# Integration example for ai_gold_grid.py
def integrate_smart_profit_manager(ai_gold_grid_instance):
    """Integrate smart profit manager into existing grid system"""
    
    # Create smart profit manager
    ai_gold_grid_instance.smart_profit_manager = SmartProfitManager(
        ai_gold_grid_instance, 
        ai_gold_grid_instance.config
    )
    
    # Add to main trading loop
    def enhanced_update_grid(self):
        """Enhanced grid update with smart profit management"""
        
        # Original grid update logic
        if not self.trading_active:
            return
            
        try:
            # Update current price
            self.update_current_price()
            
            # Check for filled orders
            self.check_filled_orders()
            
            # Update position PnL
            self.update_positions_pnl()
            
            # üß† NEW: Run smart profit management every 5 seconds
            if hasattr(self, 'smart_profit_manager') and hasattr(self, 'last_profit_check'):
                if (datetime.now() - self.last_profit_check).total_seconds() >= 5:
                    self.smart_profit_manager.run_smart_profit_management()
                    self.last_profit_check = datetime.now()
            elif hasattr(self, 'smart_profit_manager'):
                self.smart_profit_manager.run_smart_profit_management()
                self.last_profit_check = datetime.now()
            
            # Continue with original logic...
            self.check_grid_triggers()
            self.update_performance_metrics()
            self.check_emergency_conditions()
            
            self.last_update = datetime.now()
            
        except Exception as e:
            print(f"‚ùå Enhanced grid update error: {e}")
    
    # Replace the original method
    ai_gold_grid_instance.update_grid = enhanced_update_grid.__get__(ai_gold_grid_instance, type(ai_gold_grid_instance))
    
    print("‚úÖ Smart Profit Manager integrated successfully!")
    
    return ai_gold_grid_instance.smart_profit_manager